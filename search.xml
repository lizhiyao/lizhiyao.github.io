<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[写于入职丁香园三年之际]]></title>
    <url>%2F2019%2F02%2F10%2Fessay%2Fthree-year-in-dxy%2Findex%2F</url>
    <content type="text"><![CDATA[18年曾经几次动笔，想写一篇《写于入职丁香园两年之际》，最终还是没写完。主要是感觉自己的沉淀还不足，写出来的文字厚度不够。转眼间，再以入职两年为题写点什么，已经不合时宜了。回杭路上，看到企业微信最新推送的一篇文章后，突然想写点什么，算是对过去两年工作的一个总结，也算是对未来一年在杭生活的序章。 过去两年的起点，可以从17年初转岗到丁香医生开始。最开始问诊业务的载体只有 web 应用，如今业务载体新增了 App、微信小程序、今日头条小程序、SEO 友好的网站等不同形态。前端团队也从最开始的3个人变为如今的近10个人。 收获三句话这三句话分别是“心态要好，否则动作就会变形”、“要能够心如止水”和“不忘初心”。其实在生活中，可能听过、读过很多次这三句话，但是经历了一些事情后，会让我对这三句话理解的更透彻些。 心态要好17年有一段时间自己很困惑，觉得自己支持（负责）的业务方向不够清晰。这种困惑感在心里久了，会开始焦虑、急躁，从而导致与同事沟通时会更容易带情绪而忽略事实、更容易坚持个人的主观想法而不顾客观存在的因素。 这是一个典型的心态不好导致动作变形的例子。焦虑急躁实际上不能解决任何的问题。心中如果有对于工作的困惑，也应该及时的去和 leader 或者团队中更清楚业务方向的人沟通，以便于尽早消除困惑，以更好的状态去工作。在与人沟通时，最好不要带情绪，应该更加职业化的去工作。 其实还有很多可能导致一个人工作中心态变差的情形：觉得自己成长的速度比团队的成长速度快、觉得身边一些人做事不够“专业”、觉得某些协作伙伴不够“聪明”、觉得团队的一些做事方式“效率低”等等。 消极的想法都有积极看待的视角和应对的方式，工作和生活中应该尽可能避免被消极的心态影响。一个人成长速度比团队快，这是会发生的事情。此时对于这个人有两个的选择：去一个新的平台发展或者想办法让团队的成长速度更快、来带动团队的成长。此外。成长天花板这件事情，往往更多是个人在给自己设限。如果觉得身边有谁做的不够专业，最好自己能专业的做一次给身边伙伴看一下。如果自己知道更高效的做事方式，也是可以积极分享给团队的。 心如止水心如止水，可以看成是心态好的一种体现，也可以用临危不乱四个字来代替一下。把心如止水单独拎出来表述，实际上也说明在我意识到“心态要好”后，落地到具体执行过程中做的还不够。 临危不乱中的危，可以理解为工作中遇到的各种各样的问题。比如：一个可以 10s 内修复的简单 bug、突然的较大的需求变更、一个重点项目可能延期交付的风险、团队成员变化、环境要求需要进行自我否定等。这些事情发生时，去发现问题解决问题就好，没必要自乱阵脚。这一点似乎和《功夫熊猫》中的 inner peace 有异曲同工之妙。 心如止水并不是说一个人要去盲目的淡定，明明火烧眉毛了却丝毫不在意。而是做了充分的准备后，在遇到问题时，能有条不紊的让事情朝着好的方向发展。 不忘初心不忘初心也是关于做事情的心态和方式的。每个人做事情、做选择都有其出发点。回顾过去，尤其18年下半年，自己由于某些因素导致做事情时的初心发生了偏差。如今看来，一旦偏离了初心，事情是更容易做不好的。做事情还是更关注事情本身，以让事情本身变得更好为出发点会比较好。 比如：做新能源汽车，到底是为了探索实践更好的汽车能源方式？还是为了做新能源汽车可以从国家拿到巨额补贴？两者虽然都是在做新能源汽车，但是初心不一样，做事情的方式和结果就会出现差异。 团队建设17年夏天时，开始正式负责丁香医生前端团队，和前端伙伴们及业务一同成长至今。似乎有时间可以写一下《丁香医生前端团队这两年》，先在这给自己挖一个坑吧，填不填再说。总之，这是一段荣幸、难忘、有趣、酸甜苦辣咸都有的经历。 如果给自己打一个分，100分满分的话，给自己70分吧。为什么扣了30分，后面会说。 见证新业务发展简而言之，这两年经历了丁香医生业务从0到1的这个过程。目前自己是很放心的使用丁香医生的在线问诊服务，还会丝毫不怂的推荐给亲人朋友使用。也了解问诊之外的业务的一些情况，为什么会有这样的业务设计还没做到理解的很透彻，这是接下来需要去思考补足的地方。 18年去苏州体验了一天在线问诊服务的线下推广，在把这样的服务推荐给身边的人时也会听到到一些声音。在当下的互联网环境下做在线问诊服务，不是一件容易的事。 在国内 ToC 的互联网医疗行业，如何能站着把钱挣了？同样不简单。 瘦了35斤虽然现在也是一个胖子，但是比 G20 那会儿近180斤来说，已经有改善了，所以把这件事也放到了收获之中。18年的健身目标没有达到，更直接的说是执行的很差劲。希望19年能实现这个目标。 关于减肥，其实就两点：控制饮食和运动。并且两者没必要同时进行，前期可以先控制饮食，等控制饮食见效后，开始逐步增加运动量。如果非得再加一点，就是决心，说白了就是看自己到底想不想把这件事做成了。其他事情下定决心去做也不一定会成功，但是减肥这件事情下定决心来做，是可以成功的。 如果不知道该如何科学的进行减肥，可以去了解一下丁香诊所的体重管理计划。作为该减重计划种子中的种子用户，是比较推荐这项服务的。 重拾跳舞一直很喜欢这句话：”Find what you really love, and let it kill you.”。跳舞应该可以算是我的爱好之一了。大学时打了一年多的酱油，大四实习后就荒废了。幸运的是来丁香园后，认识了阿想和龙爷，组成了最早的舞蹈小分队三人组。如今舞蹈小分队已经有一个近100人的群，汇集了一群喜欢跳舞且跳的很好的伙伴，并且每周都有专业的老师来给伙伴们授课。作为挂名小分队队长的入门级选手，我心中还是挺开心的。 认识更多优秀的人坦言，觉得自己成长的速度比团队的成长速度快、觉得身边一些人做事不够“专业”、觉得某些协作伙伴不够“聪明”、觉得团队的一些做事方式“效率低”，这些想法在过去两年中我都有过，但是这类想法越来越少或者说已经趋近于零了。 可以说“每个人身上都有我学习的优点”是一句客套话，但是这也是目前内心的一个真实写照。现在可以做到更多的站在对方的视角来看待问题，从而觉得自己才是不够专业的那个人；真心的觉得身边的伙伴都挺聪明的，而自己是在问题中磕磕绊绊的前行；关于效率这事儿，同样放到后面说了。 不足关于不足，共有三点，前面提到给自己打70分，是在这三点上分别扣了10分。 技术深度这两年自己的技术，不能说是没长进，不过进步的点在于项目经验的丰富、项目管理能力的提高、技术宽度的进一步拓宽以及更能准确的衡量技术的“性价比”。但是在技术深度的进步上，没办法给自己及格分。对于一个业务技术团队，在保证良好的交付业务需求同时，加深技术的深度同样是一个需要花心思的地方。关于这一点多说无益，19年是一定要在这一点上下功夫的。 交付质量关于交付质量，会认为自己在过去犯了一个错误：在业务压力大、接触新技术平台、团队成员变化等阶段，会把交付质量的标准放的较低。这会导致团队的交付质量始终在波动。 技术团队的高质量交付，实际上应该是看家本领。即使业务方说能接受交付质量稍微差一点的上线，作为技术同学也不应该松这个口子。降低标准看上去是在给团队成员减压，实际上是在伤害技术团队和业务。出了问题的修复时间、对技术同学的信任感，这都是很宝贵的东西。 效率效率这一点，展开说又可以说很多。在自己去写代码做需求时，是很追求那种快速把事情做完且没有问题的状态，但是放到团队层面，做的不够好。年前去贝贝网参加他们的技术分享，有一个感触是：透过几场分享传达出来的技术同学追求效率的意识是很不错的。这样的状态和做事情的方式，需要在团队中尽可能的去落地。 其他先不展开了，再挖一个坑：《一个高效的前端团队是怎样的？》 感恩整体来说，过去两年对自己在花厂的成长还是会给及格分的。两年中很多人给与了我帮助和指导，在此一并表示感谢。其中文兄和东星给了我非常多的指导，比心。 持续思考在路上洋洋洒洒写了这么多文字，最后还有两个话题没有写。这两个话题自己都能给出一些答案，但是认为还是应该再持续思考一段时间，然后再尝试落笔。就算是19年又给自己挖的两个坑吧：《技术对业务的贡献在哪里？》、《作为团队 leader，最重要的是什么？》 写在最后最后，对自己说点什么吧。 希望你19年能够始终保持一个好的心态，不忘初心，努力去实现既定目标。 — 写于2019年2月10日夜]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[震惊！前端开发和设计稿居然是这样的关系]]></title>
    <url>%2F2019%2F01%2F07%2Fessay%2Frelationship-between-front-end-development-and-design%20draft%2Findex%2F</url>
    <content type="text"><![CDATA[公众号注册 2018 年深冬的下午，在需求评审会后，产品向在场的前端开发和客户端开发提出了一个问题：为什么你们评估工期需要等到最终设计稿交付？产品说他之前和设计师、技术同学合作时，技术同学是可以不用等到交付才动工的。听到这个问题的刹那间，作为和前端开发打了5年交道的我，沉默了大概10s。最终还是简单的发表了一下观点：研发同学根据设计稿评估的研发周期是最精准的。 事后就想围绕着这个问题写点文字，思来想去没有动笔，而是去买了几本书：《学习敏捷:构建高效团队》、《敏捷革命》、《人月神话》。希望自己读过书后，对这个问题能有新的认知。 今晚准备从公司回家时，收到了一条这样的消息，突然就想趁着书没读完先写写自己目前的想法。 为什么评估工期需要等到设计稿交付？回答这个问题，需要先明确题干中评估工期指的是大致的工期还是准确的工期。在文章开头提到的语境中，是指开发的功能达到可提测状态的准确时间。 其实这个问题可以从软件研发之外的行业找到答案。比如：负责房屋精装修的工人是否需要完整的效果图才可以给出装修耗时？汽车生产线是否需要设计稿确定后才可以准确评估生产一台汽车的时间？以目前我的理解，两个问题的答案都是肯定的。 从工程的角度，精准的时间评估是依赖精准的前置条件的。 产品是否需要交付视觉稿后，前端才可以开工？那么有没有一些灰度空间呢？比如：我和负责房屋装修的人是好朋友，在房屋装修的各种问题上我们已经交流了很久，此时在效果图没有最终确定前，他告诉我房屋装修所需要的时间，此时我会相信吗？要生产的新车型的很多零件，都是在其他汽车上广泛应用的配件；汽车的组装方案是基于另外一辆汽车做的修改；组装汽车的工人有着丰富的同类型汽车组装经验，此时是否能给出生产一台汽车所耗费的时间？以目前我的理解，两个问题的答案可能也都是肯定的。 这种灰度空间是哪些因素在起作用呢？大致列举众多因素中的几个：更多的交流、彼此的信任、业界通用的解决方案、丰富的实战经验。 这种灰度空间有什么问题吗？目前我认为其中最大的问题在于风险变得更大。朋友被其他事情占用了大量时间导致没有足够精力负责装修怎么办？原以为可以直接使用的汽车配件等到最终组装时发现尺码差了0.3cm，导致没办法顺利组装怎么办？ 所以说，从实践的角度，工程化的事情中是存在一定的灰度空间的。如果这种灰度空间掌控不好，会给工程带来更大的风险。 为什么我会被问到这两个问题？如何解决目前团队遇到的问题？瀑布模型 vs 敏捷开发其实这只是一个选择前端开发和设计稿到底是什么关系？随着年龄的增长，我得出这样一个结论]]></content>
      <tags>
        <tag>项目管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Code Review 在丁香医生前端团队的实践]]></title>
    <url>%2F2018%2F09%2F11%2Fcode-review%2F</url>
    <content type="text"><![CDATA[时间过得很快，转眼间 Code Review 机制在丁香医生前端团队已经运作一年多了。今年4月初时，将团队在 Code Review 方面的一些经验在丁香园前端团队进行了分享，各个业务线的前端同学们逐步开始尝试 Code Review 机制，目前也有了一定的收获。是时候将这些实践经验落实到文字上，来和更多的朋友们进行交流了。 起因世上没有无缘无故的爱，也没有无缘无故的恨。同样，也没有无缘无故的 Code Review。最开始时，丁香医生前端有2个人，基本上是1人在做丁香医生 SPA 项目，1人做丁香医生管理后台项目。 将时间点放到17年初，团队从2个人变为了3个人，此时主要有三个前端项目（丁香医生 SPA、丁香医生管理后台以及丁香医生 Hybrid App）在迭代，其中主要是 SPA 项目会涉及到三个人的交叉维护。这个阶段便会开始暴露出一些小问题。比如： 编码风格不一致 有些他人写的业务逻辑，在交叉维护时，需要花更多的时间上手 一些低级的 bug 在代码部署到测试环境才被发现 为了解决这些问题，我们决定开始尝试 Code Review。项目的代码是托管在公司内网的 Gitlab 上的，于是我们会开始摸索着基于 GitLab 中项目的 Merge Request 进行他人代码的 Code Review。 17年 Q2 时，我们开始频繁的迭代丁香医生小程序，同时运营团队也会开始提出一些运营类H5的需求。团队成员有4人了。随着新鲜血液的加入，我们遇到了新的问题： 新人的加入提高了团队代码风格的差异性 在不是很了解现有项目的基础上，实现的新功能代码会产生冗余 谁来为新成员的代码质量和成长负责？（注意：这是重要的一点） 此时我们依旧在做 Code Review，但实际上并没有严格的去执行，也没有一个关于 Code Review 的标准供大家遵守。 毫无疑问的一点：随着丁香医生业务的发展，这些问题是需要被解决的，否则长远来看无论是对于团队还是团队成员，都是有较大伤害的。 17 年 Q3 时，团队已经有 6 个人了。每加入一个新人，上述问题的复杂度就会增加一些。为了解决这些问题，团队决定将 Code Review 作为一项基本制度，严格去执行。 如何去做 Code Review？前提在开始严格的去做 Code Review 之前，我们确定了三点基础规范。 基于项目版本控制，统一项目遵守的 Git 分支模型 对于 JavaScript，使用统一的 Eslint 规则 结合团队成员现有风格，明确统一的代码规范 工具使用的工具就地取材，依旧是 GitLab。整个 Code Review 流程在 GitLab 项目中有两个点比较关键：Merge Request（简称：MR）、Discussion（简称：Diss）。 在这两点基础上，我们确定了几个角色： Owner（需求负责人，代码改动提交者，MR 发起者） Reviewers（MR 参与者，前端团队的同事，可能不止一个人。负责 Review 代码。） Disser（某个 Reviewer。对某个 MR 发起 Discussion 的人。） 流程 对 GitLab 上需要进行 Code Review 的项目进行设置（Settings - General - Merge request settings - Only allow merge requests to be merged if all discussions are resolved）。 Owner 在本地开发环境，某分支（以某功能分支 feat-example 为例）做好功能开发，充分自测后将代码推送到 GitLab。 Owner 基于 feat-example 分支，发起目标分支为 develop 分支的 MR。MR 需要有尽可能详细的描述。比如：需求文档地址，做了哪些修改，某个功能的设计实现思路，需要哪几位 reviewer 对本次 MR 进行 Code Review 等。推荐使用 MR 模板。 Owner 成功发起 MR 后，通过团队协作工作告知 Reviewers 有 MR 需要进行 Code Review，以及 MR 的紧急程度。 Reviewers 基于 MR 进行进行 code review。如果对 MR 有任何问题，在 GitLab 上针对具体代码进行 comment（发起 Discussion），review 完成后通知 Owner 结果（本次 MR 通过 / 本次 MR 有 n 个 Diss）。如果有 Diss，Owner 需要对每一个 Diss 进行回复，直至所有 Diss 的状态变更为 Resolved。 Owner 对 MR 进行 merge 操作，并在测试环境发布代码，通知相关 QA 同学测试，QA 测试通过后由 QA 通知产品和设计师进行验收。（此处有一个细节：Owner 如果确定可以进行 merge 操作？我们想到有两个方案：1. 以 Reviewers 通知 Owner 为准 2. 以 Reviewers 给 MR 点赞为准，因为 GitLab 上是可以对 MR 进行点赞操作的。目前团队采用的是第2种方式。） 如果测试或者验收环节发现问题，Owner 需要对代码进行修改，然后发起新一轮的 MR，直至测试环境代码通过验收。 和 QA 同学确认代码可以发布至生产环境，并进行代码发布，通知 case 相关同学某功能已上线。 原则在执行 Code Review 过程中，我们有一些原则需要遵守： Owner 发起 MR 之前的代码需要进行充分自测 代码版本控制 commit 的粒度不要太大 不阻塞他人的工作，尽快响应他人的 Code Review 请求（这一点比较考验团队成员的合作精神、团队意识。同时也要求开发者要合理安排自己的时间，要有能力随时放下手中的工作，随时继续手中的工作） 如果某个 MR 紧急，可以告知 Reviewers 除有必要，否则 Owner 不要在提测验收阶段删除分支（例如勾选“remove source branch when merge request is accepted.”），应等待分支合入master分支后移除，避免预发/测试分支重建时被遗漏。 定期回顾和总结 Code Review 执行情况（比如在团队周会时进行） 边界清楚了 Code Review 流程之后，其实还有一些边界情况需要考虑。我会将团队目前采用的处理策略写出来供参考。 周末出现线上紧急 bug 要遵循 Code Review 流程吗？可以不进行 Code Review，以快速修复 bug 为主。 某个需求（项目）留给开发时间非常紧张时怎么办？可以不进行 Code Review，优先保证按时需求（项目）上线。 团队内部项目、组内同学个人发起的兴趣项目是否需要进行 code review？决定权在项目 Owner。 MR 遇到代码冲突怎么办？建议在 code review 之后，由 Owner 将代码拉取到本地进行 merge 并解决冲突，然后将最新代码推送到 GitLab（此时 GitLab 上 MR 会自动 merge 掉）。 收获坦言，在一个从未进行过 Code Review 的团队想把这个机制运作起来，并不是一件容易的事情。尤其是在决定开始进行 Code Review 后的起步阶段。但是如果能认准方向，团队的成员齐心协力朝着既定的方向去走，最终会获得如下的收获的： 团队成员代码风格统一 减小了项目交叉维护的阻力 使新成员更快速融入团队 避免了低级 bug 在测试环境出现 良好的技术交流氛围 待完善上面描述的这个机制并不是完美的。目前我可以想到的可以优化的点如下： 优化编码规范（技术本身在发展，团队成员的水平在提高，随之之前定下来的编码规范也会适当的进行优化） Check List（这一点实际上目前团队已经开始做了。当业务具有一定复杂度后，某些业务逻辑的迭代难免会牵扯较多已有业务，此时如果有一份 Check List，会帮助 Owner 及 Reviewers 更好的进行 Code Review） 激励机制 代码测试用例（主要是指业务代码增加测试用例。目前团队也开始进行了一些尝试。） 自动化 写在最后将团队在使用的 Code Review 机制以文字的形式沉淀下来，主要是想分享给更多的人。如果这些文字对某些人、某些团队有帮助，那对于我来说是一件令人欣慰的事情。如果能接收到关于优化现有机制的指点，也会是一件令人开心和感激的事情。 此外，还想表达的一点是：丁香医生前端团队是一个非常在意每一个团队成员成长的团队。 我猜，你可能猜到接下来我要说什么了。 是的，随着丁香医生业务的发展，我们需要优秀的前端同学加入我们，一起茁壮肆意成长。更多关于团队的介绍，可以参考请问丁香医生前端团队怎么样？ 招聘 JD高级/资深前端工程师职位描述 负责丁香医生旗下产品的前端开发工作（网站，Web App，Hybrid App，微信小程序，管理后台，Node.js 中间层）； 依据产品的需求，优质高效的完成前端项目的开发和维护； 对产品的前端性能进行优化，确保产品具有优质的用户体验； 参与丁香园前端团队的基础平台建设； 任职条件 3 年以上前端工作经验； 熟练使用 HTML（HTML5）、CSS（CSS3）和 JavaScript（ES6/ES7）； 熟悉网络协议（HTTP/SSL）； 熟练使用 Webpack 或者 rollupjs； 至少熟练使用一种 CSS 预处理器（如：Less、Sass、Stylus）； 至少熟练使用 Vue.js、React.js、AngularJS 三种框架中的一种； 对前端开发规范、工程化、组件化、测试有一定的认识和实践； 理解并熟练使用面向对象编程思想，注重设计模式、模块化开发在实际项目中的应用； 较强的责任心，良好的沟通能力和文档编写能力； 优先条件 在简历里写明 Github 账号或个人博客地址； 独立开发过或者参与过优质的开源项目； 有实际 Hybrid App 项目开发经验； 有实际的微信小程序项目开发经验； 有高负载场景下 Node.js 应用开发和运维经验； 熟练使用 TypeScript； 熟悉使用一门非前端的编程语言（如：Java、PHP、Python、Go）； 前端实习生（全职）职位描述 负责丁香医生旗下产品的前端开发工作（网站，Web App，Hybrid App，微信小程序，管理后台，Node.js 中间层）； 依据产品的需求，优质高效的完成前端项目的开发和维护； 对产品的前端性能进行优化，确保产品具有优质的用户体验； 参与丁香园前端团队的基础平台建设； 任职条件 对编程技术有热情，期望自己在技术上有快速成长； 毕业前能够全职实习至少 6 个月； 熟练使用 HTML（HTML5）、CSS（CSS3）和 JavaScript（ES6/ES7）； 熟悉网络协议（HTTP/SSL）； 理解并熟练使用面向对象编程思想，注重设计模式、模块化开发在实际项目中的应用； 较强的责任心，良好的沟通能力和文档编写能力； 优先条件 在简历里写明 Github 账号或个人博客地址； 独立开发过或者参与过优质的开源项目； 熟练使用 Vue.js、React.js、AngularJS 三种框架中的一种； 有实际 Hybrid App 项目开发经验； 有高负载场景下 Node.js 应用开发和运维经验； 熟练使用 TypeScript； 熟练使用一种 CSS 预处理器（如：Less、Sass、Stylus）； 熟悉使用一门非前端的编程语言（如：Java、PHP、Python、Go）； 既然已经看到这里了，不如发一封邮件我们聊一下吧：lizy@dxy.cn。]]></content>
      <tags>
        <tag>Code Review</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[请问丁香医生前端团队怎么样？]]></title>
    <url>%2F2018%2F06%2F26%2Fyou-do-not-know-the-front-end-team-of-dxy-doctor%2F</url>
    <content type="text"><![CDATA[最近一直想写一些关于丁香医生前端团队的文字，却始终觉得难以动笔。去描述一个团队，可以从非常多的维度去阐述，当从某个视角去深入描写时，就会觉得很难把控描写的尺度，要么有些溺爱，要么有些苛刻，亦或者不够直接坦率。内心挣扎一段时间后，终于决定只从一个维度来写，那就是我眼中丁香医生前端团队的样子，也是面试过程中会告知面试者的一些关于团队的信息。 这是一个目前由 7 人组成的前端团队，负责维护丁香医生微信小程序、丁香医生医生端微信小程序、基于 Vue.js 全家桶的丁香医生 SPA 和丁香医生管理后台、基于 React 全家桶的丁香医生数据统计管理后台，基于 React SSR 的丁香医生官网和丁香医生移动站。在丁香医生 APP 中，我们负责基于 JSBridge 和 Vue.js 的一些页面开发（移动端的伙伴在个别页面使用了 RN）。我们在小程序迭代过程中，和设计师一起沉淀出了移动端的组件库。此外，还会去做一些有趣的项目，比如：内部数据可视化项目（我们称它为 Huston）。 前端同学日常工作中会和服务端同学、客户端同学、测试同学、产品经理、交互设计师和 UI 设计师紧密配合。目前使用 Teambition 作为基础的协作工具。需求通常会经过需求评审、排期、开发、提测、验收、发布几个主要阶段。前端团队内部以主动认领的方式领取自己想做的需求。项目的版本控制使用 Git，项目代码会统一托管在内网的 GitLab 上。内网中有私有 npm 仓库、公司统一的前端资源发布系统、公司统一使用的接口 Mock 和管理工具 Api Mocker 等服务。 一个技术团队安身立命的根本，是有着过硬的技术实力。如果这个队伍想走得远，最好能有足够具有挑战性的业务场景（需求场景）来历练。目前丁香医生前端团队用了一年的时间，让自己有了良好的的前端技术栈，接下来我们的重心会是深入掌握技术。随着丁香医生业务的快速成长，我们也会去思考、去努力让技术和业务更好的结合。 在丁香医生前端团队，我们会追寻五个词：快乐、优质、高效、成长、自由（这五个词有先后顺序）。下面是我们对这5个词的简单理解： 快乐。快乐是整个团队文化的基石。我们会认为快乐是人生的主题。每个人都应该是以快乐的状态去工作。如果做某件事情不开心，一定要及时和团队沟通。 优质、高效。高质量的交付和高效率的开发，是每个技术人员应该追求的。 成长。每个成员在工作过程中都应该是有进步的。今天的自己应该比昨日的自己有进步。 自由。在按照公司规章制度按时保质完成工作的前提下，每个成员应该有足够的自由，让其肆意成长。 写出来并不是说我们做的有多好，而是会一直朝着这个方向去做事情。 公司目前大概有 50 人左右的前端工程师，分成不同的小组支持不同的业务线。基本上每周丁香园的前端团队都会有技术分享，每个给大家做分享的伙伴会收到一份精美的礼物，比如一份手办。 17 年丁香园前端团队举办了第一届前端技术沙龙，和大搜车一起举办了第五期杭州 Node Party。 第一届丁香园前端技术沙龙 第五期杭州 Node Party 小记 此外，还有一些应该是大多数互联网公司都会提供的。比如：给前端同学配备一台 Mac Pro、两台 Dell 显示器；每个月的团建；每年免费去参加 Qcon、GMTC 等技术大会的机会；采购想看的图书等。 前端小伙伴的工作台通常是这样的： 团建聚餐后，小哥哥发了一条朋友圈： 团队所在部门是一个怎样的部门？公司有非常多的产品线。按照用户群体可以分为 toB、toD（面向医生）、toH（面向医院）、toC（面向大众）等方向。丁香医生业务部目前是一个 toC 方向的一级部门。 这是一个年轻充满活力和干劲的团队。 部门下午经常会发奶茶或者水果的车，上车的同学可以免费有一点点、星巴克或者新鲜的水果吃。 公司的环境如何？公司总部的位置在杭州市滨江区的上峰电商产业园 3 号楼。 公司有各种各样的兴趣社团，比如：篮球小分队（丁香医生前端团队有一名国家级裁判员）、足球小分队、羽毛球小分队、跳蚤小分队、街舞小分队（小分队的队长就在丁香医生前端团队）、弹唱小分队（丁香医生前端团队有一个江湖称上峰林俊杰的小哥哥）、喝酒小分队（分队创始人之一就在丁香医生技术团队）、吸猫小分队等。 公司有健身房，经常可以看到在健身的帅哥靓女们。他们的身材和气质是真的很好（丁香医生抖音号了解一下）。 公司餐吧常年有咖啡等饮品，夏季和秋季会有冷饮。 说点别的上面描述的信息，对于大多数人来说可能是重要的，这些信息会辅助他做决策。 在我的眼中，有比上面这些更重要的事情：一个人想清楚自己到底想去做什么，想清楚后能遇到志同道合的人一起去朝着心中那个方向去做。工作中能遇到配合起来可以在内心深处可以产生共鸣的人，是一件幸运的事情。在想清楚最核心的问题后，上面描述的信息才会变得更有价值。 在加入丁香园之前，我经历过两家不同阶段的创业公司，每家公司介绍中都会有一些名词，比如：硅谷、海归、微软、（14年左右的）手游行业、O2O（还记得几年前创业大潮中死掉的那些贴着 O2O 标签的公司吗？），还和朋友一起注册过两家公司（注册公司就会经历股权分配、股权变更等从0到1的过程），这些经历会让我对公司这个词有更清晰的认识以及对公司存在的问题的容忍度变得更大。《安娜卡列尼娜》中会说“幸福的家庭都是相似的 不幸的家庭各有各的不幸”，实际上对于公司来说也是一样的，每家公司都有它的优势和不足。一个人加入或者离开一家公司，是两者在各自成长阶段从合适变得不合适的过程。 说了这么多，是时候亮出丁香医生前端团队招聘的 JD 了。是的，随着丁香医生业务的快速增长，我们前端团队需要优秀的同学加入，来一起做些有趣、有挑战的事情。 职位描述 负责丁香医生旗下产品的前端开发工作（网站，Web App，Hybrid App，微信小程序，管理后台，Node.js 中间层）； 依据产品的设计需求，优质高效的完成产品前端的开发和维护； 对产品的前端性能进行优化，确保产品具有优质的用户体验； 参与丁香园前端团队的基础平台建设； 任职条件 3年以上前端工作经验； 熟练使用 HTML（HTML5）、CSS（CSS3）和 JavaScript（ES6/ES7）； 熟悉网络协议（HTTP/HTTPS等）； 熟练使用 Webpack 或者 rollupjs； 对前端开发规范化、工程化、组件化、测试有一定的认识和实践； 理解并熟练使用面向对象编程思想，注重设计模式、模块化开发在实际项目中的应用； 至少熟练使用 Vue.js、React.js、AngularJS 三种框架中的一种； 较强的责任心，良好的沟通能力和文档编写能力； 优先条件 在简历里写明 Github 账号或个人博客地址； 独立开发过或者参与过优质的开源项目； 有实际 Hybrid App 项目开发经验； 高负载场景下 NodeJS 应用开发和运维经验； 熟练使用 TypeScript； 熟练使用一种 CSS 预处理器（如：Less、Sass、Stylus）； 熟悉使用一门非前端的编程语言（如：Java、PHP、Python、Go）； 招聘 JD 写的比较正式，简单来说就是希望新加入的同学可以轻松 hold 住上面提到的各种类型的项目（因为团队现在的小伙伴们，每个人都可以做到这一点）。如果能在某些方面有深入的掌握，这会是加分项（最近团队有一个小伙伴在看 Vue.js 的源码，欢迎来一起交流）。在做事情方面，踏实可靠肯付出是基石，良好的事情推进能力和沟通表达能力是加分项。 实际上，一个优秀的前端工程师，可选的工作机会有很多。如果看到这篇文字的你正在找工作，或者正在考虑换一个工作环境，欢迎来找我聊一下。如果觉得丁香医生前端团队的岗位不合适，丁香园还有其他的前端岗位供你选择。如果还是不能满足求职需求，我可以让在阿里、网易的朋友帮你内推一下，也可以把你的简历给到有赞、大搜车等公司的技术负责人。在最近连续拿了几轮融资的宋小菜带团队的 Scott 也在招人，他们 RN 和 GraphQL 玩的多一些，想去的话也可以帮忙引荐。 既然已经看到这里了，不如发一封邮件我们聊一下吧：lizy@dxy.cn。]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端工程师的成长之路]]></title>
    <url>%2F2018%2F06%2F26%2Ffront-end-engineers-growth%2F</url>
    <content type="text"></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[好的前端团队氛围是怎样的？]]></title>
    <url>%2F2018%2F06%2F26%2Fwhat-is-a-good-work-environment-for-front-end-engineers%2F</url>
    <content type="text"><![CDATA[写下这份文字的标题后，发现这个话题并不是很好写。因为每个人对于工作环境的要求和对于“好”的定义，是不一致的。思来想去，还是决定来写一写，一来是已经把坑的范围缩小在前端这个范围了，自己在前端领域摸爬滚打这些年，多少有一点经验；二来是告诉自己不要怂，要勇于把目前的认知尝试表达出来；第三个原因，准备放在文字最后写。 谈到工作环境，我们先把视角拉到公司层面来看一下。大致可以分为三种公司：初创公司、有规模性盈利能力的公司和巨头公司。]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[丁香医生关于 Node 的科普]]></title>
    <url>%2F2018%2F04%2F07%2Fnode-0%2F</url>
    <content type="text"></content>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[写于入职丁香园两年之际]]></title>
    <url>%2F2018%2F03%2F31%2Ftwo-year-in-dxy%2F</url>
    <content type="text"><![CDATA[这份文件创建于2018年3月31日，整整晚了入职花厂两周年一个月的时间。时至今日，18年已经过去了一半。这期间打开过几次编辑器，想把这份总结写完，可总是写了删，删除了再写，最终留下只言片语。 大学毕业的越久，越觉得时间过得很快。似乎再不去写这份文字，就该去写《写于入职丁香园三年之际》了。于是，下定决心把这份文字补充完整。 最大收获如果抛开流水账般的描述，第二年最大的收获可以总结为两点：第一点是八个字，分别是不忘初心和心态要好；第二点是有机会和一个小的前端团队一起成长。不忘初心是刚开始负责丁香医生前端团队时文兄对我说的，初心实际上可以说出是目标、是方向、是做事情的方式和初衷等等，人一旦想清楚自己的初心，有些决定就会更好做出，有些难题就会更有毅力干掉。心态要好大概是是在Q3尾巴时期，印象最深的是“一个人心态不好，他做的事情就会变形。如果一个人做的不好，那么我们应该以专业的方式和态度让他知道什么是好的以及如何可以做的更好”。这样的理念会让自己在今后的做事过程中更有耐心，并会经常提醒自己去找寻更专业的方法和方式。关于团队，自己见证了丁香医生前端技术团队的成长。从自己加入时从2人变为3人，以及后来扩大到6个人；从军树的离开，到炜烽、舒哲、顾重、程琳的加入；从代码风格、技术能力、项目经验各不相同，到代码风格统一、整个团队完全可以hold住不同类型的项目；从看到某些case的结果有些无奈，到完全放心每一个人去独立负责业务需求，这些事情回顾起来历历在目。关于第二点，最后会详细说。 流水账下面以流水账的方式回顾一下在花厂的第二年，做了哪些事情。 Q1 熟悉来问丁香医生项目（一个基于 Vue.js 全家桶的 SPA），]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018 fitness]]></title>
    <url>%2F2018%2F02%2F24%2F2018-fitness%2F</url>
    <content type="text"><![CDATA[2月份大部分人训练强度之低，根本轮不到拼训练体系。 0223 墙壁俯卧撑50*3 垂直引体50*3 肩倒立深蹲50*3 短桥50*3 坐姿屈膝50+20 仰卧起坐20]]></content>
      <tags>
        <tag>健身</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序 textarea 组件踩坑之旅]]></title>
    <url>%2F2018%2F02%2F07%2Fios-weapp-textarea%2F</url>
    <content type="text"></content>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mixins 被认为是有害的]]></title>
    <url>%2F2018%2F01%2F05%2Fmixins-considered-harmful%2F</url>
    <content type="text"><![CDATA[目前团队在维护的项目中，主要使用的前端框架是 Vue.js。最近组内同学在学习 React 的时候，问了我一个问题：Vue.js 的 mixins 在 React 中是如何实现和使用的？ 当时自己回忆了一下之前两个 React 的项目经历，给出的的回答是：mixins 本质上是用于代码的复用，自己在写 React 的时候，基本上是通过抽象通用组件和函数、props实现的代码复用，没太考虑过使用 mixins。 事后反复思考这个问题，觉得自己给的答案并不能让自己满意，于是又去学习了一个。学习过程中发现了 React 官博的一篇文章Mixins Considered Harmful，看过之后基本解决了心中的困惑。 现将原文翻译如下： “如何在不同的组件之间进行代码复用？”是人们在学习 React 时首先要问的问题之一，我们的答案始终是使用组件组合来重用代码。你可以定义一个组件并在其他几个组件中使用它。 某种确定的模式通过用组合的方式进行解决并不总是显而易见的。React 受函数式编程的影响，但进入了以面向对象库为主的领域。Facebook 内部和外部的工程师很难放弃他们习惯的模式。 为了简化最初的采用和学习，我们在 React 中加入了一些“逃生”功能。mixin 系统就是其中一种逃生方法，它的目标是当你不知道如何通过组合解决问题时，给你另外一种在组件之间重用代码的方法。 React 已经发布三年了，前端领域的技术在这三年中也发生了翻天覆地的变化。现在多个用于构建用户界面的前端框架都采用了类似于 React 的组件模型。使用基于继承的组合声明式的构建用户界面，不再是新鲜事物。我们对 React 组件模型也更加自信，我们在内部和社区都看到了它的许多创造性的用途。 在这篇文章中，我们将思考通常是由 mixin 引起的问题。然后，我们将为相同的用例提出几种替代模式。我们发现随着项目代码复杂度的增加，这些替代的模式的可扩展性比使用 mixin 更好。 为什么 Mixins 在 React 中不被推荐使用在 Facebook，React 的使用量已经从几个组件增长到了成千上万个。这给了我们一个去思考人们该如何更好的使用 React 的窗口。由于声明性渲染和自上而下的数据流，许多团队在采用 React 去实现一些新功能时，能够解决了很多之前难以去解决的 bug。 然而，使用 React 的一些代码不可避免地变得难以理解。有时候，React 团队会看到开发者不敢去碰某些项目中的组件。这些组件维护起来很容易出 bug，对新开发人员造成负担，最终组件会变得让创建这个组件的人都难以去维护。这种巨大的开发成本大部分是由 mixin 引起的。当时，我并没有在Facebook工作，但是在写下了我可怕的 mixin 之后，我得出了相同的结论—Mixins已经，组合永生。 这并不意味着 mixin 本身就是坏的。开发者们成功地在不同的语言和范例中使用 mixin，包括在一些函数式编程语言中。在 Facebook，我们广泛使用 Hack 中与 mixin 非常相似的特性。但是，我们依旧认为 mixin 在 React 代码库中是不必要的和有问题的。下面的内容是我们这样认为的原因。 Mixin 引入了隐式依赖关系有时一个组件依赖于mixin中定义的某个方法，比如getClassName（）。有时候是相反的，mixin在组件上调用renderHeader（）方法。 JavaScript是一种动态语言，所以很难执行或记录这些依赖关系。 Mixin打破了常见且通常安全的假设，即可以通过在组件文件中搜索其出现来重命名状态键或方法。你可能会写一个有状态的组件，然后你的同事可能会添加一个读取这个状态的mixin。在几个月内，您可能需要将该状态移至父组件，以便与兄弟组件共享。你会记得更新mixin来读取道具吗？如果现在其他组件也使用这个mixin呢？ 这些隐含的依赖性使新团队成员难以贡献代码库。一个组件的render（）方法可能会引用一些未在该类上定义的方法。移除安全吗？也许它是在一个mixin中定义的。但是其中哪一个呢？您需要向上滚动到mixin列表，打开每个文件，然后查找此方法。更糟的是，mixin可以指定他们自己的mixin，所以搜索可以很深入。 mixin经常依赖于其他的mixin，而删除其中的一个会打破另一个。在这些情况下，告诉数据如何进出mixin是非常棘手的，以及它们的依赖关系图是什么样的。与组件不同，mixin不构成层次结构：它们被夷为平地并在相同的名称空间中运行。 Mixins导致名称冲突不能保证两个特定的mixin可以一起使用。例如，如果FluxListenerMixin定义了handleChange（）和WindowSizeMixin定义了handleChange（），则不能一起使用它们。你也不能在你自己的组件上定义一个带有这个名字的方法。 如果你控制混入代码，这不是什么大不了的事情。如果发生冲突，可以在其中一个mixin上重命名该方法。然而，这很棘手，因为一些组件或其他mixin可能已经直接调用这个方法，你也需要找到并修复这些调用。 如果你的名字与第三方包中的mixin有冲突，你不能只重命名一个方法。相反，您必须在您的组件上使用尴尬的方法名称以避免冲突。 mixin作者的情况并不好。即使向mixin添加一个新的方法总是一个潜在的重大改变，因为一个名称相同的方法可能已经存在于一些使用它的组件，直接或通过另一个mixin。一旦写入，mixin很难删除或更改。不好的想法不会被重构，因为重构风险太大。 Mixin导致复杂的滚雪球即使mixin开始简单，随着时间的推移，它们往往会变得复杂。下面的例子是基于我在代码库中看到的真实场景。 组件需要一些状态来跟踪鼠标悬停。为了保持这个逻辑可重用，你可以将handleMouseEnter（），handleMouseLeave（）和isHovering（）提取到一个HoverMixin中。接下来，有人需要实施一个工具提示。他们不想复制HoverMixin中的逻辑，以便创建使用HoverMixin的TooltipMixin。 TooltipMixin读取HoverMixin在其componentDidUpdate（）中提供的isHovering（），并显示或隐藏工具提示。 几个月后，有人想让工具提示方向可配置。为了避免代码重复，他们添加了一个名为getTooltipOptions（）的新的可选方法到TooltipMixin。到目前为止，显示popovers的组件也使用HoverMixin。然而，popovers需要不同的悬停延迟。为了解决这个问题，有人增加了对可选的getHoverOptions（）方法的支持，并在TooltipMixin中实现它。那些混合现在是紧密耦合的。 没有新的要求，这很好。但是这个解决方案不能很好地扩展。如果你想支持在单个组件中显示多个工具提示呢？你不能在一个组件中定义两次相同的mixin。如果工具提示需要在导游中自动显示，而不是悬停，怎么办？祝你好运解耦TooltipMixin从HoverMixin。如果您需要支持悬停区域和工具提示锚点位于不同组件的情况，该怎么办？你不能轻易地把混入到父组件中的状态提升起来。与组件不同，mixin不会自然地适应这种变化。 每一个新的要求都会让混音变得更难理解。使用相同mixin的组件越来越与时间耦合。任何新的能力被添加到使用该mixin的所有组件。如果没有复制代码或在mixin之间引入更多的依赖性和间接性，就没有办法拆分mixin的“更简单”的部分。逐渐地，封装边界逐渐消失，由于很难改变或移除现有的混合，他们不断变得抽象，直到没人理解它们是如何工作的。 这些与我们在React之前构建应用程序的问题是一样的。我们发现它们是通过声明性渲染，自顶向下的数据流和封装组件来解决的。在Facebook上，我们一直在迁移我们的代码以使用替代模式来混合，我们对结果普遍感到满意。你可以阅读下面的模式。 从Mixin迁移让我们清楚地说明mixin在技术上并不被弃用。 如果你使用React.createClass（），你可以继续使用它们。 我们只是说他们不适合我们，所以我们不会推荐将来使用他们。 下面的每个部分对应于我们在Facebook代码库中找到的mixin使用模式。 对于他们每个人，我们描述这个问题和一个我们认为比mixin更好的解决方案。 这些例子是用ES5编写的，但是一旦你不需要mixin，你可以根据需要切换到ES6类。 我们希望你觉得这个列表有帮助。 请让我们知道，如果我们错过了重要的用例，所以我们可以修改列表或被证明是错误的！ 性能优化PureRenderMixin是最常用的混合类型之一。 当道具和状态与以前的道具和状态相似时，你可能会在某些组件中使用它来防止不必要的重新渲染： 12345678var PureRenderMixin = require('react-addons-pure-render-mixin');var Button = React.createClass(&#123; mixins: [PureRenderMixin], // ...&#125;); 解决方案要表达同样没有mixin，你可以直接使用shallowCompare函数： 12345678910var shallowCompare = require('react-addons-shallow-compare');var Button = React.createClass(&#123; shouldComponentUpdate: function(nextProps, nextState) &#123; return shallowCompare(this, nextProps, nextState); &#125;, // ...&#125;); 如果你使用一个自定义的mixin以不同的算法实现一个shouldComponentUpdate函数，我们建议从一个模块导出这个单一的函数，并直接从你的组件中调用它。 我们知道更多的打字可能会令人讨厌。 对于最常见的情况，我们计划在下一个小版本中引入一个名为React.PureComponent的新基类。 它使用与PureRenderMixin相同的浅度比较。 订阅和副作用我们遇到的第二种最常见的mixin类型是将一个React组件订阅到第三方数据源的mixin。 无论这个数据源是Flux Store还是Rx Observable，这个模式都非常相似：订阅是在componentDidMount中创建的，在componentWillUnmount中销毁，并且更改处理程序调用this.setState（）。 123456789101112131415161718192021222324252627282930313233343536373839var SubscriptionMixin = &#123; getInitialState: function() &#123; return &#123; comments: DataSource.getComments() &#125;; &#125;, componentDidMount: function() &#123; DataSource.addChangeListener(this.handleChange); &#125;, componentWillUnmount: function() &#123; DataSource.removeChangeListener(this.handleChange); &#125;, handleChange: function() &#123; this.setState(&#123; comments: DataSource.getComments() &#125;); &#125;&#125;;var CommentList = React.createClass(&#123; mixins: [SubscriptionMixin], render: function() &#123; // Reading comments from state managed by mixin. var comments = this.state.comments; return ( &lt;div&gt; &#123;comments.map(function(comment) &#123; return &lt;Comment comment=&#123;comment&#125; key=&#123;comment.id&#125; /&gt; &#125;)&#125; &lt;/div&gt; ) &#125;&#125;);module.exports = CommentList; 解决方案如果只有一个组件订阅了这个数据源，那么将订阅逻辑嵌入组件中就好了。 避免过早抽象。 如果有几个组件使用这个mixin来订阅一个数据源，避免重复的一个好方法就是使用一个叫做“higher-order components”的模式。 这听起来有些吓人，所以我们将仔细看看这种模式是如何从组件模型中自然产生的。 更高级的组件解释让我们忘记一秒钟的反应。 考虑这两个函数添加和乘数，记录结果，因为他们这样做： 1234567891011function addAndLog(x, y) &#123; var result = x + y; console.log('result:', result); return result;&#125;function multiplyAndLog(x, y) &#123; var result = x * y; console.log('result:', result); return result;&#125; 这两个函数并不是非常有用，但是它们帮助我们演示了一种可以稍后应用于组件的模式。 假设我们想从这些函数中提取日志逻辑而不改变他们的签名。 我们应该怎么做？ 一个优雅的解决方案是编写一个更高阶的函数，也就是一个将函数作为参数并返回一个函数的函数。 再一次，这听起来比实际上更吓人： 12345678910function withLogging(wrappedFunction) &#123; // Return a function with the same API... return function(x, y) &#123; // ... that calls the original function var result = wrappedFunction(x, y); // ... but also logs its result! console.log('result:', result); return result; &#125;;&#125; withLogging高级函数让我们可以在没有日志语句的情况下编写add和multiply，然后将它们包装到addAndLog和multiplyAndLog中，并使用与之前完全相同的签名： 123456789101112131415161718192021function add(x, y) &#123; return x + y;&#125;function multiply(x, y) &#123; return x * y;&#125;function withLogging(wrappedFunction) &#123; return function(x, y) &#123; var result = wrappedFunction(x, y); console.log('result:', result); return result; &#125;;&#125;// Equivalent to writing addAndLog by hand:var addAndLog = withLogging(add);// Equivalent to writing multiplyAndLog by hand:var multiplyAndLog = withLogging(multiply); 高阶组件是一个非常相似的模式，但应用于React中的组件。 我们将通过两步来从mixin中应用这个转换。 作为第一步，我们将把我们的CommentList组件分成两部分，一个孩子和一个父母。 孩子只会关心评论。 家长将通过道具设置订阅并将最新的数据传递给孩子。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// This is a child component.// It only renders the comments it receives as props.var CommentList = React.createClass(&#123; render: function() &#123; // Note: now reading from props rather than state. var comments = this.props.comments; return ( &lt;div&gt; &#123;comments.map(function(comment) &#123; return &lt;Comment comment=&#123;comment&#125; key=&#123;comment.id&#125; /&gt; &#125;)&#125; &lt;/div&gt; ) &#125;&#125;);// This is a parent component.// It subscribes to the data source and renders &lt;CommentList /&gt;.var CommentListWithSubscription = React.createClass(&#123; getInitialState: function() &#123; return &#123; comments: DataSource.getComments() &#125;; &#125;, componentDidMount: function() &#123; DataSource.addChangeListener(this.handleChange); &#125;, componentWillUnmount: function() &#123; DataSource.removeChangeListener(this.handleChange); &#125;, handleChange: function() &#123; this.setState(&#123; comments: DataSource.getComments() &#125;); &#125;, render: function() &#123; // We pass the current state as props to CommentList. return &lt;CommentList comments=&#123;this.state.comments&#125; /&gt;; &#125;&#125;);module.exports = CommentListWithSubscription; 只剩下最后一步了。 还记得我们如何使用Logging（）取得一个函数并返回包含它的另一个函数？ 我们可以将相似的模式应用于React组件。 我们将编写一个名为withSubscription（WrappedComponent）的新函数。 它的参数可以是任何React组件。 我们将通过CommentList作为WrappedComponent，但是我们也可以将SubScription（）应用到代码库中的任何其他组件。 这个函数会返回另一个组件。 返回的组件将管理订阅并使用当前数据呈现。 我们称这种模式为“高阶组件”。 构图发生在React渲染级别，而不是直接函数调用。 这就是为什么使用createClass（）定义包装组件是ES6类还是一个函数并不重要。 如果WrappedComponent是一个React组件，那么通过withSubscription（）创建的组件可以呈现它。 12345678910111213141516171819202122232425262728293031// This function takes a component...function withSubscription(WrappedComponent) &#123; // ...and returns another component... return React.createClass(&#123; getInitialState: function() &#123; return &#123; comments: DataSource.getComments() &#125;; &#125;, componentDidMount: function() &#123; // ... that takes care of the subscription... DataSource.addChangeListener(this.handleChange); &#125;, componentWillUnmount: function() &#123; DataSource.removeChangeListener(this.handleChange); &#125;, handleChange: function() &#123; this.setState(&#123; comments: DataSource.getComments() &#125;); &#125;, render: function() &#123; // ... and renders the wrapped component with the fresh data! return &lt;WrappedComponent comments=&#123;this.state.comments&#125; /&gt;; &#125; &#125;);&#125; 现在我们可以通过应用CommentList来申明CommentListWithSubscription： 123456789101112131415161718192021var CommentList = React.createClass(&#123; render: function() &#123; var comments = this.props.comments; return ( &lt;div&gt; &#123;comments.map(function(comment) &#123; return &lt;Comment comment=&#123;comment&#125; key=&#123;comment.id&#125; /&gt; &#125;)&#125; &lt;/div&gt; ) &#125;&#125;);// withSubscription() returns a new component that// is subscribed to the data source and renders// &lt;CommentList /&gt; with up-to-date data.var CommentListWithSubscription = withSubscription(CommentList);// The rest of the app is interested in the subscribed component// so we export it instead of the original unwrapped CommentList.module.exports = CommentListWithSubscription; 再探解决方案现在我们可以更好地理解高阶组件，下面再看看不涉及mixins的完整解决方案。 内嵌评论有一些小的更改： 123456789101112131415161718192021222324252627282930313233343536373839404142434445function withSubscription(WrappedComponent) &#123; return React.createClass(&#123; getInitialState: function() &#123; return &#123; comments: DataSource.getComments() &#125;; &#125;, componentDidMount: function() &#123; DataSource.addChangeListener(this.handleChange); &#125;, componentWillUnmount: function() &#123; DataSource.removeChangeListener(this.handleChange); &#125;, handleChange: function() &#123; this.setState(&#123; comments: DataSource.getComments() &#125;); &#125;, render: function() &#123; // Use JSX spread syntax to pass all props and state down automatically. return &lt;WrappedComponent &#123;...this.props&#125; &#123;...this.state&#125; /&gt;; &#125; &#125;);&#125;// Optional change: convert CommentList to a functional component// because it doesn't use lifecycle hooks or state.function CommentList(props) &#123; var comments = props.comments; return ( &lt;div&gt; &#123;comments.map(function(comment) &#123; return &lt;Comment comment=&#123;comment&#125; key=&#123;comment.id&#125; /&gt; &#125;)&#125; &lt;/div&gt; )&#125;// Instead of declaring CommentListWithSubscription,// we export the wrapped component right away.module.exports = withSubscription(CommentList); 高阶组件是一个强大的模式。 如果要进一步自定义其行为，可以将其他参数传递给它们。 毕竟，它们甚至不是React的一个特征。 它们只是接收组件并返回包装它们的组件的函数。 像任何解决方案一样，高阶元件也有自己的陷阱。 例如，如果大量使用refs，则可能会注意到将某些东西包装到高阶组件中会将ref更改为指向包装组件。 在实践中，我们不鼓励使用ref来进行组件通信，所以我们不认为这是一个大问题。 将来，我们可能会考虑将ref转发给React来解决这个问题。 渲染逻辑我们在代码库中发现的mixin的下一个最常见的用例是在组件之间共享渲染逻辑。 这是这种模式的典型例子： 123456789101112131415161718192021222324252627282930var RowMixin = &#123; // Called by components from render() renderHeader: function() &#123; return ( &lt;div className='row-header'&gt; &lt;h1&gt; &#123;this.getHeaderText() /* Defined by components */&#125; &lt;/h1&gt; &lt;/div&gt; ); &#125;&#125;;var UserRow = React.createClass(&#123; mixins: [RowMixin], // Called by RowMixin.renderHeader() getHeaderText: function() &#123; return this.props.user.fullName; &#125;, render: function() &#123; return ( &lt;div&gt; &#123;this.renderHeader() /* Defined by RowMixin */&#125; &lt;h2&gt;&#123;this.props.user.biography&#125;&lt;/h2&gt; &lt;/div&gt; ) &#125;&#125;); 多个组件可能共享RowMixin来渲染标题，并且每个组件都需要定义getHeaderText（）。 解决方案如果你看到一个mixin中的渲染逻辑，那么就是抽出一个组件的时候了！ 而不是RowMixin，我们将定义一个组件。 我们还将用React中的顶层数据流的标准机制替换定义getHeaderText（）方法的约定：传递道具。 最后，由于这些组件当前都不需要生命周期钩子或状态，我们可以将它们声明为简单的函数： 12345678910111213141516function RowHeader(props) &#123; return ( &lt;div className='row-header'&gt; &lt;h1&gt;&#123;props.text&#125;&lt;/h1&gt; &lt;/div&gt; );&#125;function UserRow(props) &#123; return ( &lt;div&gt; &lt;RowHeader text=&#123;props.user.fullName&#125; /&gt; &lt;h2&gt;&#123;props.user.biography&#125;&lt;/h2&gt; &lt;/div&gt; );&#125; 通过使用Flow和TypeScript这样的工具，支持组件的依赖关系是显式的，易于替换和可执行的。 注意：将组件定义为函数不是必需的。 使用生命周期钩子和状态也没什么问题 - 它们是一流的React功能。我们在这个例子中使用了功能组件，因为它们更容易阅读，我们不需要那些额外的功能，但类将工作得很好。 Context我们发现的另一组mixin是提供和使用React上下文的助手。 上下文是一个实验性的不稳定的特征，有一定的问题，将来可能会改变它的API。 我们不建议您使用它，除非您确信没有其他方法可以解决您的问题。 不过，如果你今天已经使用上下文，你可能已经隐藏它的使用mixin这样的： 1234567891011121314151617181920212223242526272829303132var RouterMixin = &#123; contextTypes: &#123; router: React.PropTypes.object.isRequired &#125;, // The mixin provides a method so that components // don't have to use the context API directly. push: function(path) &#123; this.context.router.push(path) &#125;&#125;;var Link = React.createClass(&#123; mixins: [RouterMixin], handleClick: function(e) &#123; e.stopPropagation(); // This method is defined in RouterMixin. this.push(this.props.to); &#125;, render: function() &#123; return ( &lt;a onClick=&#123;this.handleClick&#125;&gt; &#123;this.props.children&#125; &lt;/a&gt; ); &#125;&#125;);module.exports = Link; 解决方案我们同意，在上下文API稳定之前，隐藏使用组件的上下文使用是个好主意。 不过，我们建议使用更高阶的组件，而不是mixin。 让包装组件从上下文中获取一些东西，并用道具传递给包装组件： 12345678910111213141516171819202122232425262728293031323334function withRouter(WrappedComponent) &#123; return React.createClass(&#123; contextTypes: &#123; router: React.PropTypes.object.isRequired &#125;, render: function() &#123; // The wrapper component reads something from the context // and passes it down as a prop to the wrapped component. var router = this.context.router; return &lt;WrappedComponent &#123;...this.props&#125; router=&#123;router&#125; /&gt;; &#125; &#125;);&#125;;var Link = React.createClass(&#123; handleClick: function(e) &#123; e.stopPropagation(); // The wrapped component uses props instead of context. this.props.router.push(this.props.to); &#125;, render: function() &#123; return ( &lt;a onClick=&#123;this.handleClick&#125;&gt; &#123;this.props.children&#125; &lt;/a&gt; ); &#125;&#125;);// Don't forget to wrap the component!module.exports = withRouter(Link); 如果您使用的是仅提供混音功能的第三方库，我们鼓励您向他们提交链接到该帖子的问题，以便他们可以提供更高级别的组件。 与此同时，您可以用完全相同的方式自行创建一个更高阶的组件。 效用方法有时，mixin仅用于在组件之间共享实用程序功能： 12345678910111213141516171819202122var ColorMixin = &#123; getLuminance(color) &#123; var c = parseInt(color, 16); var r = (c &amp; 0xFF0000) &gt;&gt; 16; var g = (c &amp; 0x00FF00) &gt;&gt; 8; var b = (c &amp; 0x0000FF); return (0.299 * r + 0.587 * g + 0.114 * b); &#125;&#125;;var Button = React.createClass(&#123; mixins: [ColorMixin], render: function() &#123; var theme = this.getLuminance(this.props.color) &gt; 160 ? 'dark' : 'light'; return ( &lt;div className=&#123;theme&#125;&gt; &#123;this.props.children&#125; &lt;/div&gt; ) &#125;&#125;); 解决方案将实用函数放入常规JavaScript模块并导入它们。 这也使得更容易测试它们或者在你的组件之外使用它们： 123456789101112var getLuminance = require('../utils/getLuminance');var Button = React.createClass(&#123; render: function() &#123; var theme = getLuminance(this.props.color) &gt; 160 ? 'dark' : 'light'; return ( &lt;div className=&#123;theme&#125;&gt; &#123;this.props.children&#125; &lt;/div&gt; ) &#125;&#125;); 其他用例有时候人们会使用mixins来选择性地将日志记录添加到某些组件的生命周期钩子中。在将来，我们打算提供一个官方的DevTools API，它可以让你在不触及组件的情况下实现类似的东西。然而，这仍然是一项正在进行的工作。如果你严重依赖日志混合进行调试，你可能想要继续使用这些混合。 如果你不能用一个组件，一个更高级的组件或者一个实用程序模块来完成某件事情，那么React应该意味着它应该提供这个开箱即用的功能。提出一个问题，告诉我们你的mixins用例，我们将帮助你考虑替代方案，或者实现你的功能请求。 Mixins在传统意义上不被弃用。您可以继续使用它们与React.createClass（），因为我们不会进一步改变它。最终，随着ES6类获得更多的采用，并且React中的可用性问题得到解决，我们可能会将React.createClass（）分割成单独的包，因为大多数人不需要它。即使在这种情况下，你的旧mixins仍然会继续工作。 我们相信，上述替代方案对绝大多数情况都更好，我们邀请您尝试在不使用mixin的情况下编写React应用程序。 相关阅读 Why Are Mixins Considered Harmful?]]></content>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[告别是为了彼此变得更好---SPA 前后端彻底分离的探索之路]]></title>
    <url>%2F2018%2F01%2F03%2Ffarewell%2F</url>
    <content type="text"><![CDATA[前后端分离，目前对于一个前端开发者来说，或者将其放在软件开发领域的历史背景下，都是再平常不过的一件事情了。17 年时进行了一个前后端彻底分离方案的实践，每次想起来这个方案时，总觉得它不够完美。现在将其写下来和大家交流，期望可以促进方案的后续完善。 邂逅自从接触前端开发，一共接触到了三种前端项目发布的方式： 通过 FileZilla 直接将前端资源文件上传到业务服务器 SSH 到业务服务器，通过 Git 更新前端项目代码，然后进行新版本资源的构建 将构建好的前端资源文件推送到 cdn 刚加入丁香园前端团队时，前后端分离的 SPA 项目的实现方式是：前端和服务端项目是两个代码仓库，HTML 模板由服务端语言（JSP/PHP）输出，HTML 引用的前端资源是通过前端资源发布系统发布到 cdn 上。涉及到 cdn，就会面临 cdn 缓存的问题。解决 cdn 缓存问题的方案是传统的时间戳机制。具体操作流程是服务端提供一个更新时间戳的接口，当前端每次发布新版本后，去调用更新时间戳的接口。 基于时间戳机制的前端项目发布流程大致为： 在发布系统进行项目发布 通过相关接口更新时间戳 看上去这个流程很简单高效，对不对？让我们来根据实际情况来细化一下这个流程： 登录发布系统 在发布系统点击对应项目的发布按钮 等待前端资源构建并发布成功 资源发布成功后，调用更新时间戳的接口 发布完成 流程细化之后，我们可以把流程分为5步，平均算下来每次前端同学进行一次项目发布，大概需要3分钟。在等待发布系统构建资源的时候，前端同学可以并行的去做一些放松的事情，比如：去餐吧喝杯咖啡，上个厕所，随手修个 bug。放松之后，更新一下时间戳，新版本发布便大功告成。接下来便可以进入愉悦的新需求开发之旅了，一切都显得如此惬意。 去年的我，也是这样认为的。因为当时在负责的新版调查问卷（SPA）和 Insight（可以看做 n 个 SPA）等项目，大概平均每天发布一次，所以用来发布的时间成本还是能接受的。 16年年底时，加入了大众医学部，开始和伙伴们一起负责来问丁香医生等项目。项目依旧是前后端分离的 SPA，构建好的前端资源依旧是发布到 cdn，解决 cdn 缓存问题同样采用的是时间戳机制。一切都是熟悉的配方，熟悉的味道。当参与了一段时间的需求迭代后，我发现事情似乎没有想象的那么简单。 让我有这种感受的原因，主要有两点： 更新时间戳的接口即使在内网，也是需要鉴权的。并不像调查问卷等项目，直接在浏览器访问一下更新时间戳的接口就可以了。鉴权的方式是需要微信扫码。 需求迭代速度谦虚一点说，很快。仅生产环境，几乎每天都要发布至少一次。 此时细化的一次发布流程变为： 登录发布系统 在发布系统点击对应项目的发布按钮 等待前端资源构建并发布成功 资源发布成功后，调用更新时间戳的接口（需要鉴权） 访问更新时间戳的页面，页面弹出鉴权二维码 发布者拿起手机 打开微信，点击扫一扫，扫描二维码 微信接收到同意授权的模板消息 点击模板消息进行授权，授权成功后进入更新时间戳页面 点击更新时间戳按钮 等待生效（服务端有缓存机制） 发布完成 一次前端发布的时间，平均在7分钟左右。在实际工作中，需要在测试环境、（预发环境）、生产环境进行发布。从团队的角度来看，管理后台等项目也在采用这种发布方式。毛估一下，每周团队在项目发布上就需要花费 2 ~ 3 个小时((7min 2 2 * 5)/ 60)。 此外，这种前后端分离的方式还有以下几个问题： HTML 模板开发效率较低。项目所使用的 HTML 文件需要前端同学写好后发给后端，后端再进行“套模板”，这种做法本身就有一个流程的复杂度。后端同学如果对 HTML 掌握的不熟练，那么需要前端同学去跟后端同学结对编程，来确保 HTML 的正确，此处有一个沟通成本。项目上线后，如果需要对 HTML 进行改动，需要前端先修改好 HTML，然后把 HTML 发给后端，后端再次进行“套模板”。后端同学修改好 HTML 模板文件后，可能不会因为这一个改动进行发版，需要跟随着后端项目的其他改动代码一起发版，此时对于前端、测试同学有一个等待的成本。 cdn 资源有一点点浪费。页面中所有前端资源是使用同一个时间戳，这意味着每次更新时间戳都会更新页面中的全部资源引用地址，从而当用户再次使用应用时，需要重新下载页面引用的所有资源。而前端的某个新版本，可能仅仅是需要更新部分资源文件即可。 加长了应用的响应时间。这一点同样是由上一点描述的时间戳机制导致的，重新下载“新”的资源而不是利用浏览器的缓存，必然会导致用户需要等待更长的时间。 念念不忘，必有回响为了解决上述问题，我设计了一个的方案： 方案说明： 前端项目生产环境构建时，将文件名中加入 hash 值。 前端资源发布系统在资源构建成功后，将 index.html 同步到业务服务器（本着线上项目不做写操作的原则：会把 HTML 文件放到后端项目和Node项目目录之外的地方）。 在业务服务器上新增一个 Node 服务。该服务的作用之一为：收到浏览器端首页的请求时，将 index.html 返回。 当用户访问应用时，由运维将请求首页 HTML 的请求转给 Node 服务，其余业务接口保持原有方式不变。 方案确定后，在团队小伙伴的配合下，该方案在一个流量较小的项目上线了。 新的火花上述方案存在一个问题的：在原有的技术体系中，引入了 Node.js。本质上是在稳定的技术体系下，增加了技术复杂度。因此，在不增加技术复杂度的前提下，需要开始探索新的解决方案。在后端同学的配合下，新方案相比于引入 Node.js 方案改动如下： 业务服务器给前端发布系统提供同步 HTML 模板文件的接口，前端发布系统每次成功构建前端资源后，调用该接口将模板文件同步给业务服务器。 业务服务器获取模板文件后，将文件内容存入数据库，持久化存储模板。在服务重启和用户请求时，服务端从数据库中获取模板。 服务端可以将从数据获取的模板放到缓存中，这样可以避免高频的读取数据库操作。对应的业务服务器需要监控数据库中的数据变化情况，以便于及时更新缓存中的模板资源。 方案上线后，前端项目的发布流程变为： 登录发布系统 在发布系统点击对应项目的发布按钮 等待前端资源构建并发布成功 前端项目发布这件事，终于变成了点击一下发布按钮，整件事情就做好了。整个发布流程耗时变为不到一分钟。此外，当前端需要改变 HTML 模板时，也不再需要将文件发给后端同学，苦苦等待后端项目的发版。 该方案上线后，组内同学在周报中提及到的使用新方案后的感受为： 为了方便前端同学获取同步模板的进展，在发布系统中增加了同步过程的提醒： 没有银弹上述方案相比于 JSP/PHP 提供 HTML 模板存在一个问题，就是在前端在构建 HTML 时，（暂时）不能将应用初始化的数据放入 HTML 中。解决方案是服务端提供一个接口，在应用启动时去调用该接口获取初始化数据。 对于前端加载优化，整体上思路上是需要减少网络请求的，而此方案却在增加网络请求，这意味着页面加载时间会变长。但是综合利弊之后，还是决定采用这个方案。 最终方案上线后，其实心中已经做好了页面平均加载时间会变长的心理准备，但是有些意外的是，几天后去 mta 看数据发现全国范围内平均响应时间缩短了 0.2s 左右。为什么不升反降，目前我还不能得出一个准确的答案。猜测的一个原因是： hash 值的方案避免了用户进行不必要的资源更新。 待完善上述方案虽然做到了前端项目的一键发布，但是还不够称作为一个完善的解决方案。因为该方案只是解决了 SPA 类型项目的发布问题，对于之前“套模板”重 SEO 的项目而言，并不是很适用。（提到 2018 年的技术浪潮下，如何开发一个重 SEO 的网站这个话题，又可以写一篇文章了，其中的心路历程还是蛮坎坷的） 言归正传，在前端资源发布系统层面，该方案可以考虑去增加文件历史和发布回滚功能，以备不时只需。 这个方案是和业务线的服务端同学配合实现的，从公司层面来看，可以考虑的点是是否可以将这个方案做成一个通用的服务。 在和团队的交流时，相学长提出可以将 HTML 引用的资源抽象成 JSON Tree 进行存储。之前看过一些类似的解决方案，不过目前自己还是更倾向于分开的“更彻底”，这样可以让服务端同学更安心的提供接口。 写在最后由于水平有限，欢迎大家对此方案提出建议。非常期待。]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初级前端项目加载速度优化]]></title>
    <url>%2F2018%2F01%2F02%2Floading-speed-optimization%2F</url>
    <content type="text"><![CDATA[这份文字是根据近期团队做来问丁香医生 SPA和丁香医生小程序加载速度优化的经历整理而成。 微信扫一扫，体验丁香医生小程序： 效果古人有一句话叫做：治感冒看疗效。既然是关于速度优化的，我们就先来看一下优化的效果。 来问丁香医生 Chrome Network选取了访问量较大的首页和我的页面进行随机取样，通过下图可以看到首页的加载时间从 5.1s 下降到 1.67s，我的页面从 2.92s 下降到 1.82s。 优化前首页 我的页面 优化后首页 我的页面 mta2018.01.02 早上的页面响应速度数据，目前国内各省份平均加载速度在 0.99~2s（虽然没有达到 1s 内加载，但是以目前业务量级，这样的速度是可以被接受的）： Google PageSpeed Insights 和 pagespeed insights Chrome 插件前者这是 Google 的一个评分工具，最开始做优化时用它测了一些页面的分数。后来发现了后面这些 Chrome 插件。让我困惑的是同样的页面这几个工具给出的结果分数都不一样。手淘 的首屏加载速度挺快的，但是跑出来的分数也不高。最终我只是选择性的参考一下工具给出来的建议，忽视了其给出的评分。 丁香医生小程序对于小程序，做了优化后得到部门同学的反馈是这样的： 具体的数据指标如何呢？虽然目前没有特别好用的性能检测方式（包括官方提供的性能检测工具在内），最终我们组的舒哲同学还是利用官方提供的工具做了一下简单的数据对比，数据如下： 在不影响产品需求正常迭代的前提下，两个项目的优化断断续续持续了两周。整体上来说，本次优化的性价比还是较高的。 为什么做加载速度优化？直接原因很简单：慢。虽然说页面加载速度并没有达到慢的让人无法忍受，但至少没办法让人说加载很快。 既然明知道加载速度不快，那之前在干什么？为什么不早早的去做优化呢？ 这是一个好问题，我曾经在深夜中问过自己多次。我给自己的答案是：首先，要承认自身技术水平和经验的限制，如果是一个在前端战场上身经百战的人一直在负责项目的迭代，或许情况会比优化前好一些。 其次，之前整个产品线的项目一直处于探索和快速迭代中，前端研发资源基本上总是处在被需求排满的状态下，产品需求快速上线的优先级是最高的。正是因为产品的整体节奏稍微放缓了一些，才让研发资源有精力来做一些优化。 为什么说是前端响应速度优化，而不是前后端？因为我是亲眼看着这两个项目逐渐长大的，单从前端工程的角度来审视，在自己的认知范围内，早就认为项目中有一些地方是需要优化的。坚定了先从前端动手的想法，是因为读了《高性能网站建设指南》这本书，书中提到了一个性能黄金法则（Performance Golden Rule）：只有 10% ~ 20% 的最终用户响应时间是花在下载 HTML 文档上。话说到这个份上，还犹豫什么呢，先从前端项目开始撸起袖子加油干吧。 之前去 Qcon 等技术大会上，听过几次关于加载速度的分享。比如：使用 HTTP2，整站级别的前后端优化等。方案确实是好的方案，但具体是否要应用到自己团队实际项目中，还得根据执行成本、团队技术储备等维度从长计议。 为什么说是初级？因为深感自己在前端性能优化这个领域还有很长的路要走。 如何做的？前戏这么长，终于可以开始了。 来问丁香医生 SPA先看图（绿色部分为已在项目中应用的方法）： 实现游客机制最初来问丁香医生是基于微信服务号做的，当时的设计是用户通过服务号菜单进入应用时，会自动帮他进行跳转登录，登录成功后服务端再重定向回到应用。登录这个环节，虽然与项目代码层面的加载优化关系不大，但是从用户体验的角度这样的流程是不好的。因为相比于直接打开页面，用户需要等更长的时间，并且会看到两次页面加载的进度条。从产品的角度，一些页面是不需要用户登录即可访问的。综上，将登录流程后置，让用户可以直接进入应用这件事情，于情于理都是必须要做的。 改造流程大致为：梳理产品现有流程 -&gt; 用户进入应用时取消强制登录 -&gt; 在产品流程核心环节进行用户登录状态判断并引导登录。具体实现细节不再赘述。 减小资源包体积实现了游客机制后，接下来就是对应用的资源包动手了。因为通过 Chrome 开发者工具的 Network 可以看出，下载 CSS、JS 资源还是占用了不少时间的。下图是减小资源包体积之前的情况： 优化前包体积大小-Gzipped 精简第三方依赖想要减少资源体积大小，首先需要知道哪些资源时应该/可以被删除的。由于项目是基于 Webpack 构建的，因此可以使用Webpack Bundle Analyzer进行分析Webpack 生成的包体组成。然后根据实际情况进行移除就好。 精简了第三方依赖后，启动应用时需要下载的资源体积还是挺大的。此时就需要使用 Webpack 的代码分离和懒加载进行进一步的优化。 代码分离代码分离的思想就是化整为零，将代码分离到不同的 bundle 中，然后可以按需加载或并行加载这些小的 bundle 文件。 代码分离主要是利用 Webpack 的动态导入 Webpack 目前有三种常用的代码分离方法： 入口起点：使用 entry 配置手动地分离代码。（优势：简单、直观。劣势：配置繁琐、同一份代码可能会被引入到各个 bundle 中、不灵活，并不能将核心应用程序逻辑进行动态拆分代码） 防止重复：使用 CommonsChunkPlugin 去重和分离 chunk。 动态导入：通过模块的内联函数调用来分离代码。 经过对比之后，最终选择了动态导入的方式。 动态导入(dynamic imports)webpack 提供了两个类似的技术： import() 语法（推荐，符合 ECMAScript 提案） require.ensure（webpack 钦定） 示例1234// 分离 lodashasync function getComponent() &#123; const _ = await import(/* webpackChunkName: "lodash" */ 'lodash');&#125; 懒加载懒加载是在代码分离的基础上更近了一步。 虽然我们可以将代码进行代码分离，但代码分离后的 bundle 只是加载的优先级会不同，最终还是会加载，但实际情况是某些代码在用户进行某项操作之前是不需要加载的。比如：个人信息编辑页面有一个用户修改头像功能，对于用户来说，即使他进入了个人信息编辑页面，在他未点击上传按钮之前，用于上传头像的代码是没必要加载的。 Vue-Router 结合 Vue 的异步组件和 Webpack 的代码分割)功能，实现了路由组件的懒加载。 在经过精简依赖、代码分离和懒加载之后，项目的资源包体积大小如下图： Gzipped： 用户进入首页需要加载的 js 资源从 vendor.js、main.js 和 chunks 共 672.84kb 变为只需要加载一个 186kb 的 main.js。 复用 Store 数据以减少网络请求数量来问丁香医生是基于 Vue.js 全家桶实现的，状态管理用的是 Vuex。 之前的实现中，有些功能实现没有很在意 Store 数据的复用。比如：从 A 页面进入 B 页面后再返回 A 页面时，会再去获取端获取一次 A 页面需要的数据。这种处理不仅仅是多发了不必要的请求，如果在请求过程中做了一些页面级别加载中的处理，那么每次切换页面时都会让用户看到 loading 效果，这也会让人觉得加载慢。既然用了状态管理，那么就应该把他利用好才是。 本次优化过程中的数据复用，主要是在部分请求 action 之前增加逻辑判断，如果 Store 中有当前操作需要的数据，则不再调用 action。 前后端彻底分离关于这一点会再写一篇文章进行阐述。 丁香医生小程序老规矩，先看图： 图片资源最开始做小程序时，是把所有图片资源 base64 后进行使用的，这导致了所有图片资源最终都被打包到小程序的安装包中。所以做小程序的加载速度优化的第一步，就是把一些体积较大的图片资源改为使用线上资源。具体做法是将素材先上传到 cdn，然后在小程序中直接使用线上图片地址。 登录鉴权优化原本小程序的登录是我们自己实现的一套登录方案，核心是前后端一起维护一个类似于 SessionId 的 ID。服务端对于这个 ID 是设置了有效期的，而之前前端的实现是每次用户启动小程序，都直接去请求公司的 SSO 获取一个新的 ID，没有在意本地的 ID 是否过期。 优化的点在于在应用启动时，增加对 ID 有效期的判断，从而避免每次用户启动都需要发请求获取新的 ID。 预渲染之前在小程序所有需要从服务端获取数据的页面，都实现了一个加载中的效果，即请求未返回结果时，整个页面用户只会看到一个加载中的菊花。如果某页面只有服务端提供的元数据级别接口，没有业务接口，并且接口返回的数据是有依赖关系的，那么用户等待的时间会大大加长。 仔细思考会发现，其实是没有必要等所有接口数据回来后再给用户呈现完整页面的。 最终的优化方案分为两种：一种是取消加载中效果，先给用户呈现完整的利用本地数据渲染好的页面，等接口返回数据后在进行页面视图的更新；另外一种方案是取消加载中效果，但是不做本地数据渲染，而是直接给用户看到部分静态页面。 分包加载关于分包加载，就老老实实的按照官方文档做就好了。进行分包后的效果还是很不错的。具体效果可以参考文章开头的数据统计。 目前上述方案中，效果比较明显的是预渲染和分包加载。一个是视觉上让用户觉得快了，一个是真真切切的把首次加载的资源包变小了。 总结 软件的性能，在编写第一行代码开始，到软件的生命周期结束，都应该给予足够的重视（在做项目写代码的过程中能规避可能出现的性能问题，是需要一定的技术功底的，在实现的时候也不一定非得强求性能，慢慢修炼就好）。 在涉及到项目架构层面的改动时，一定一定要做足够的回归测试（经历过的热都应该知道为什么会这么说）。 要学会用数据说话。 结束了吗？No！前端性能优化这条路，路漫漫其修远兮。]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017 Qcon 上海站游记]]></title>
    <url>%2F2017%2F10%2F18%2F2017-qcon-shanghai%2F</url>
    <content type="text"><![CDATA[又是一年，Qcon 上海站。 从报名之前浏览会议内容简介开始，到第三天最后一场分享结束，有一种感受贯穿始终：今年的会议内容与去年的 Qcon 上海站大不相同，一个技术人的成长一定要能够跟上时代的变化。因为“一个人的命运啊，当然要靠自我奋斗，但是也要考虑到历史的进程。” 去年参加完 Qcon 后，结合自己的经历，写了一篇关于前端的一些思考，提到了当时大会比较火的几个词是：前端、微服务、大数据、云平台。而今年很难用几个关键词把会议内容概括起来，因为内容涉及的很广泛。如果一定要总结出几个相对火热的关键词，我把它概括为：人工智能、机器学习、大数据、云计算。 下面以我参加的分享内容为主线，来沉淀一下本次技术大会的收获。 第一天重拾极客精神，提升技术认知这是 Qcon 上海的开场活动，可以称其为极客邦科技的新产品极客时间的发布会。在半个小时的环节中，有四点让我有感触。 一是坚持去做一件事，并把这件事情做好做成。如果没记错的话，极客邦科技在国内做技术分享已经做了10年。自己所在的公司丁香园，已经做了17年。在成就一件事情的过程中，其中必定包含着酸甜苦辣，如果事情的结果是好的，抛开其中包含的商业因素等，整个付出的过程还是值得点赞的。回归到个人，可以问自己几个问题：自己在未来生活中的方向是什么呢？在向着这个方向前行的过程中，应该去做哪些事情？去做这些事情的过程中，自己能坚持多久呢？ 二是当今这个时代，至少在国内，知识和知识付费还是大有可为的。知识付费这几年很火，得到、知乎live、各种在线教育等产品层出不穷。这些产品本质上还是抓住了人的一些本性。如果自己从一个用户的角度去仔细思考这些产品的定位和设计，还是蛮有趣的。朦胧中，我认为将来会有一款垂直于医疗健康领域的知识付费产品成为爆款。拓展一下，作为一个技术人员，可以去思考在知识付费的浪潮中，是不是可以做些什么？ 三是极客邦赞助了 Vue.js 企业一年营收的千分之三。企业回馈开源社区这件事，不多说，打call就是了。 四是关于极客这个词。看图说话： “深蓝” 20 年之后的人工智能原以为自己是个人工智能的门外汉，加上演讲者是复旦大学计算机科学技术学院的教授和博导，心中暗想本场分享的收获要大打折扣了。结果这个教授的演讲功力十足，给大家带来了一场酣畅淋漓的关于人工智能的演讲。整场分享包含了他个人很多独到的观点。分享开始他便声明以下内容观点仅代表个人，所以目前在 Qcon 官网也找不到关于本次分享的 PPT。下面为当时拍照记录下的两张图： 这张图片左侧的图片是一个在灯下找钥匙的故事，当有人问灯下找钥匙这个人确定钥匙丢在灯下了吗，灯下的人回答说不确定，在灯下找是因为他仅仅可以看到灯光照亮的地方。图片右侧是列举了人工智能发展过程中，人们曾以为的“未来”。目前是第 8 个深度学习。 这张图是整场分享的最后一张 PPT。 自然语言人机交互开发者平台这是阿里巴巴人工智能实验室北京研发中心总负责人带来的一场分享，目前在官网同样找不到这一场分享的 PPT。印象中，在刚开场时，不知道是不是受到了上一场教授分享的影响，还是本身演讲者的表达风格就是如此，稍微有些底气不足的样子。分享内容稍微让我入戏后，开始介绍起了阿里的一个人工智能平台，这让我有些出戏。这个平台给开发者提供了丰富的接口，“可以让完全不懂人工智能的人来轻松使用”。总体上，还是为他们在这条路上的探索点赞的。科研路漫漫归科研，将科研阶段性的成果成功的应用到商业是另当别论的。 【海外】AI 驱动全球支付业务革新 / Using AI to Revolutionize Global Payments这是 PayPal 资深总监，全球风险管理建模团队负责人带来的分享，AI 和支付是两个我完全不熟悉的领域，整场分享听下来总的印象是：AI + 具体商业行为 = 更高的回报 由创业到独角兽，技术团队如何从跟随业务到驱动业务微盟 CTO / 技术 VP 许多小的决定会影响最后的决策 方向要清晰 不同阶段，战略不同，适合最重要 团队里面需要很多好老师 需要且值得花时间去思考清楚“用途” 越底层，越需要通用设计 技术原则：简单、少付出、容错、灵活、公平 技术前瞻：突破舒适区、抓风口&amp;不跟风、预测风口 先满足核心需求不代表提供半成品 时间是最大的成本，快速决策实验 反馈闭环很重要 因时而变，因势而治 接下来同样是两次关于管理的分享，分别是顺丰科技研发副总监的《向前一步——年轻技术管理者的涅槃重生》和腾讯的一个高级管理顾问带来的《从“作坊”到“专业”，团队管理三要点》。 前者是一个不到三十岁年轻的女孩子，分享中有值得思考学习的地方，但有些表达和观点和自己的认知有出入。后者是一个专业的顾问，演讲内容和风格都偏学院派，是从企业发展的维度来谈管理。 有机会单独写写管理相关的文字吧，修行在路上。 WebAR 技术与应用场景第一天下午的第四场去听了 WebAR，进入会场的时候会场中人不多，显得有些冷清。正常分享的核心是介绍了阿里系 UC 浏览器自己研发的 UC WebAR，和自己预期的出入较大。 QCon 晚场｜7 Niubility 技术嘉年华之夜这是第一次参加 Qcon 的夜场活动，活动分了七个方向的议题，包含了容器计算、深度学习、大数据、直播技术、大数据时代的运维技术、传统企业上云、Go的未来在什么方向。由于丁香医生最近在做上云，就侧重的听了一下上云相关的讨论。 第二天Java 9 新特性好久没写 Java 了，凭借着大学时的记忆，强行去听了一波儿 Java9 的新特性。 如何在 2016 年高效的打造一个 aPaaS 平台？美洽 CTO 一场质量较高的分享。 aPaaS = Application + Platform as a Server 技术是实现商业目的的实现手段。 简单清晰的世界观：一切都是服务。对于前端来说，一切都是数据。 你不想要电钻，你只想要打好的孔。 每一次决策都是一次 Trade off（权衡，抉择，取舍）。 元数据元数据就是数据的数据。 以不变应万变 将行为以数据的方式存储 数据库其实就是最好的元数据服务 元数据驱动是解决复杂业务的最好的抽象 微服务 服务大小适中 服务边界清晰 各团队能够各自安好 分布式系统 Distributing everything 对无状态和有状态分别处理 数据安全，系统高可用，流量分散都需要分布式系统来解决 Golang发展最迅猛的服务端语言。 其他 归根结底互联网行业的资产只有人 架构不是用来救火的，而是一开始就要想清楚的 人不是越多越好 用人也不能只看履历和名气 技术是这个行业最大的变量，用好它 淘宝前端工程体系：DEF之前办丁香园首届前端沙龙时，请了在阿里手淘工作的大学校友来分享，他的分享内容涉及到了 DEF。通过这次分享更加了解了 DEF 体系。这是一套优秀的关于前端工程化的实践，点赞。 前端工程不是万金油，个人或小团队适当工具化即可，不同的业务形态和组织结构有与之匹配的工程解决方案。 面向 SPA 与 Hybrid 应用的前端工程体系与实践经验有些失望。 架构服务于业务，工程体系服务于架构。 WebAssembly 核心原理、应用与未来展望WebAssembly 是什么？ 是一种以 .wasm 作为后缀的二进制文件 可以通过 JS 接口直接在浏览器加载、解析和运行 运行在浏览器的安全沙箱内 从 HTTP2 到 QUIC——QQ 空间 Web 加速实践HTTP2 + QUIC 极客之夜｜极客的时间都去哪儿了？夜场活动是池建强、陈皓、二爷、朱赟他们四个人的一个对话交流。交流之后有现场观众交流互动环节。 有一个问题想提问，但是没有去提问。 仔细思考后，隐约有了答案 每个人的阅历不一样，回答也不一样，回答的内容也不定适合自己 现场观众的问题，实际上只要自己多思考多实践，都能解决的。 第三天【海外】未来的编程和 C++ 的作用C++之父 Bjarne Stroustrup 【海外】如何成为行家——系统工程师修炼之道Stripe / 软件工程师 印象最深，最喜欢的一场。 真正的热爱。这种热爱会传递、感染他人。 演讲 PPT 所有内容均是自己画的。 比萨的故事——Microservice &amp; Serverless偏介绍 AWS 的一个服务。 怎样构建产品和技术之间的合作氛围本质上是 owner 心态，把对方当成自己人，大家一起把事情做成。 越过山丘，已回不了头一个从技术转产品多年的产品经历的自述和思考。 Kotlin 实现 DSL了解了一下 Kotlin。 TypeScript 的发展进程自从 15 年底在 Angular1 中使用 TS 后，就很喜欢 TS，认为这是大型前端项目的最佳选择。所以果断去听了这场分享，想知道他人眼中 TS 的发展进程是怎样的。 其他小米直达服务一种新型的应用形态 听云应用性能监控平台 思考教别人做人做事要慎重 报道出了偏差是要负责的 知行合一]]></content>
      <tags>
        <tag>Qcon</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[puppeteer]]></title>
    <url>%2F2017%2F09%2F29%2Fpuppeteer%2F</url>
    <content type="text"><![CDATA[puppeteer，当你看到这个词时，你脑海中第一反应是什么？木偶戏？还是不认识这个单词？ 在 GitHub 上 puppeteer 这个项目的描述是：]]></content>
  </entry>
  <entry>
    <title><![CDATA[为什么选择 Hybrid App？]]></title>
    <url>%2F2017%2F08%2F01%2Fwhy-hybrid-app%2F</url>
    <content type="text"><![CDATA[这是给自己挖的坑。待填。 目前我共有 3 次 hybird app 开发的经历。 第一次是15年后半年在一个创业团队时。选择 hybird 方式的理由很简单：开发资源严重不足。整个团队的研发资源只有我和另外一个科大的研究生哥们儿。两个人既要写前端，又要撸后端。当时前端技术选型以 Angular1 为主，所以就选择了基于 angualr 的 Ionic。产品的主要业务是家教 O2O，大概半个月的时间做出了 app 的第一版。所以，hybird app 给我的第一印象是开发效率高。 第二次是16年夏天，在丁香医生 app 中尝试了 React Native。 第三次是今年年初至今，在丁香医生 app 中使用了 JavaScript Bridge 的方式进行开发。 参考 WebViewJavascriptBridge JsBridge]]></content>
      <tags>
        <tag>Hybrid</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[减肥日记]]></title>
    <url>%2F2017%2F07%2F22%2Flose-weight-record%2F</url>
    <content type="text"><![CDATA[2017（目标：140）早餐午餐晚餐运动反思/总结/感受 20170722（148.2）腰围 97cm，臀围 95cm总结饮食6.20 ~ 7.22 这一个月的时间虽然几乎每餐都有拍照，但是并没有坚持将照片整理成文档，做详细的饮食记录。饮食习惯总体上和之前差不多。一个月中除了平日的普通吃饭外，夹杂着一些顿聚餐。 随便选了几张拍的照片： 运动这一个月的时间有过一些运动。平均下来每周 2 次健身房的样子（每次健身房大概一个小时）。总体上还是没有养成运动的习惯。 20170721（147.8） 20170720（147.7） 20170719（147.8） 20170718（147.7） 20170717（147.2） 20170716（148.8） 20170715（150.4） 20170714（151.4） 20170713（151.6） 20170712（151.4） 20170711（152.1） 20170710（152.6） 20170709（152.7） 20170708（152.2） 20170707（152.2） 20170706（151.7） 20170705（152.6） 20170704（151.3） 20170703（151.9） 20170702（152.3） 20170701（150.7） 20170630（151.5） 20170629（152.7） 20170628（153.6） 20170627（153.9） 20170626（153.7） 20170625（153.2） 20170624（153.7） 20170623（153.9） 20170622（154.1） 20170621（154.3） 20170620（154.1） 20170619（155.1）早餐 一杯豆浆、两个鸡蛋 午餐 鸡腿套餐（剩了1/3米饭） 晚餐 夏日果蔬沙拉（吃了其中的地瓜片、黄瓜片、胡萝卜丁、几片青菜页） 加餐 一个梨运动1-4-1俯卧撑3，深蹲105，仰卧起坐20*3。 反思/总结/感受今天感觉很虚，做了几组下来就做不动了。勉强做完给自己定的最低标准。 可能是由于连续 4 天没运动的缘故。 也可能和今天下雨有关吧。 身边运动的小伙伴说：熬夜容易虚胖。保持7-8小时睡眠才有力气搬砖健身。自己的睡眠也就在六个小时左右，似乎需要提高睡眠质量。 20170618（154.7）早餐 无午餐 永和豆浆的套餐饭（蛋炒饭、猪排、一杯橙汁） 晚餐 鲈鱼、凉皮 加餐 1/4个西瓜、3/4杯抹茶红豆风暴 运动 无反思/总结/感受感觉明早体重还会增加。内心严重的罪恶感。 20170617（154.3）早午餐 两个Q蒂小蛋糕、一个KFC的小鸡腿 晚餐 火腿炒蒜薹、番茄炒鸡蛋、一个小地瓜、1/2罐菠萝低醇啤酒 加餐 一盒冰糖雪梨饮料 运动 无反思/总结/感受由于某种原因，坚持了一段时间的饮食运动规律，被自己破坏了。内心难过。 20170616（154.3）早餐 一杯豆浆、两个鸡蛋 午餐 小份黄焖鸡、一碗米饭 晚餐 萝卜牛腩、土豆丝、小鸡腿、1/3米饭 运动 无反思/总结/感受原本计划晚上去健身房的，结果临时有事情没有去。不应该。 20170615（153.3）早餐 一杯豆浆、两个鸡蛋、一块巧克力 午餐 一份牛肉粉丝、一个烧饼 晚餐 一份拌馄饨、一个鸡腿 运动 健身房蹦跶两个小时 20170614（154.5）早餐 一杯豆浆、一个鸡蛋、一个叉烧包 午餐 小份黄焖鸡、一碗米饭 晚餐 半个鸡蛋、辣椒炒鸡蛋、鸡排、1/4米饭 运动 20170613（155.5）早餐 一杯豆浆、两个鸡蛋 午餐 一份杂酱面、一个鸡蛋 晚餐 萝卜牛腩、土豆丝、小鸡腿、1/4米饭 运动反思/总结/感受 20170612（154.6）早餐 一杯豆浆、两个鸡蛋 午餐 台湾卤肉饭套餐（剩了1/2米饭） 晚餐 土豆丝、大鸡腿、小鸡腿、1/4米饭 运动反思/总结/感受 20170611（155.0）早餐 无午餐 非常难吃的中式快餐（酸菜鱼、家常豆腐）吃了酸菜鱼中的一些鱼肉、家常豆腐、1/2米饭。 晚餐 一包汤达人泡面、一根香肠运动打扫房间卫生、清洁厨房、超市购物 20170610（156.0）早餐 一盒 200ml 全脂牛奶午餐 一份小份黄焖鸡、一碗米饭晚餐 老北京火锅运动今天搬家，一天的大多数时间都在收拾东西和搬东西 20170609（156.6）早餐 一个鸡蛋、一盒200ml牛奶、一盒南瓜饼 午餐 一份鸡蛋瘦肉米粉 晚餐 排骨、荷包蛋、1/2米饭 运动 无 20170608（156.7）早餐 一个鸡蛋、一盒200ml牛奶、一盒红豆包 午餐 12个酸菜猪肉水饺、一个鸭腿 晚餐 排骨、荷包蛋、1/2米饭 运动1-4-1俯卧撑 4，仰卧起坐 20 3，深蹲 10 5，大臂哑铃 15 3。 反思/总结/感受今晚见到叔贵的训练，自愧不如。同样的时间，运动量和强度至少是我的三倍。榜样。努力。 20170607（156.8）早餐 一个鸡蛋，一盒200ml牛奶、一个南瓜饼 午餐 一碗骨汤拉面 晚餐 一碗豆浆、半个杂粮煎饼 运动 和同事一起学习 Good Time 一个小时 在叔贵的带领下，运动 40 min 20170606（158.1）早餐 一个鸡蛋、一个土豆丝卷饼午餐 团队聚餐（老北京火锅）晚餐 牛排、荷包蛋、1/2米饭 运动热身。1-4-1俯卧撑 3，仰卧起坐 20 3，深蹲 10 * 5。 20170605（157.7）早餐 一根玉米、一个鸡蛋、一杯豆浆 午餐 水煮肉、韭菜炒鸡蛋、半碗米饭 晚餐 排骨、荷包蛋、1/3米饭 水果一个苹果、1/4个西瓜 运动健身房蹦跶了一个半小时。扒了一个舞蹈视频 [Good Time - Owl City &amp; Carly Rae Jepsen / Beginner’s Class](https://www.youtube.com/watch?v=-CvsJvXqNDc） 反思/总结/感受今天和营养师进行了沟通，回顾了过去半个月的饮食情况。 总体上还是需要尽可能多的 去吃蛋白质含量多的食物，减少碳水化合物的摄取。 能少吃两口主食就少吃两口。 20170428（163.0）报名了丁香诊所为期一年的健康管理计划。 20170203（166.0）在吉林过年后回到杭州，体重为166斤。回吉林一周的时间胖了4斤。 2016（163.0）2016 年体重最重时近 180 斤。如下是自己记录在锤子便签中的内容。可见2016年4月9号的体重是89.9kg。 G20 从吉林回杭州后，决定减肥。2016年9月8号的体重为86.9kg。经过一个多月的控制饮食和运动，16年体重最轻的时候为80.4kg（即160.8斤）。随着冬天的到来以及其他一些原因，过年回吉林时体重大概在163斤左右。]]></content>
      <tags>
        <tag>减肥</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[website stress test]]></title>
    <url>%2F2017%2F07%2F11%2Fwebsite-stress-test%2F</url>
    <content type="text"><![CDATA[参考 终极 Web 应用性能和压力测试工具 Gor goreplay node-ab httperf tcpcopy]]></content>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web security]]></title>
    <url>%2F2017%2F07%2F08%2Fweb-security%2F</url>
    <content type="text"><![CDATA[主要分为两个方面，一方面是应用程序使用的第三方脚本的漏洞，另一方面是应用程序自身的代码漏洞。 前者通常通过安装第三方脚本升级补丁（升级）等手段解决，以下是针对后者进行描述。 XSS（Cross Site Scripting）本质就是对用户的输入没有进行过滤，导致恶意脚本在浏览器端被执行。 跨站漏洞类型 存储型跨站 反射性跨站 基于 DOM 跨站 挖掘跨站漏洞方式 手工 自动化 半自动化 基本防御 限制用户输入的字符串长度 对用户输入的字符串进行过滤 对用户输入的字符串进行编码 利用已有的防御 XSS 插件进行防御（http only 属性） 逻辑漏洞如何挖掘？ 经验 方法 CSRF（Cross Site Request Forgery）/ SSRF（Server-Side Request Forgery） SQL 注入]]></content>
  </entry>
  <entry>
    <title><![CDATA[软件开发过程中应该注意什么？]]></title>
    <url>%2F2017%2F06%2F11%2Fd2d-summary%2F</url>
    <content type="text"><![CDATA[2017 年 Q2 即将结束。回想上半年，可以说是从一次又一次的项目上线中走过来的。从首当其冲的来问丁香医生重构版到丁香医生 App v6.0，再到丁香医生小程序，以及最近的丁香医联体（D2D）。 周五的时候和研发相关的同事们一起开了一个 D2D 的总结会，个人认为这个会很有价值，下面将其中的一些内容记录下来。 项目周期任何一个产品的研发都可以分为 从0到1 和 产品上线后的迭代 两个阶段。无论哪个阶段，都不应该把项目的周期拉的太长。无论是产品还是研发，都要尽量去避免这个情况的发生。周期越长，遇到不可控因素的风险就越大（比如其他项目的优先级被提高、项目的开发人员由于某些原因的变动）。项目成员久久看不到胜利的曙光，可能会导致士气低落，也可能会导致项目成员开始疲劳战（希望通过更多的时间投入换取项目的早日上线）。如果由于种种原因，周期很长在所难免，那么应该考虑如何在整个周期中划出几个时间节点，让参与项目的人在每个节点之间都品尝到收获的快感。 项目排期这里的排期是指需求文档和设计稿明确后，研发人员对完成产品需求的时间评估。这是每一个开发人员都会面临的问题，这也是开发人员最容易翻船的地方。项目排期出现严重偏差可以大致分为内因和外因两种。 内因是对于开发者来说的。开发者总是会过于乐观的给出项目的完成时间。这个问题上经验丰富的开发犯错的几率会小一些，但也难说永远不会犯错。解决这个问题一方面是靠一线开发者自身的经验的提升，另一方面也需要项目的研发负责人在全局有一个把控。 外因可以有很多。常见的是来自需求方的压力：期望/要求项目在某个时间节点上线。如果公司的发展确实需要在特定的节点上线某一款产品/更新某个功能，那么把开发人员评估出来的时间点稍微提前一点点，通过加班等方式保证项目上线，是一种可选的方案。但是从工程的角度来说，这种要求对项目的潜在伤害挺大的。对于整个研发团队来说，长期的压缩研发周期也不是一件利大于弊的事情。目前我的观点是：减少外因对于排期的干扰，核心的办法是沟通。可能会比较难沟通，但沟通了总会比把巨大的压力丢给一线研发人员好。 项目文档项目文档是指：需求文档、后端接口文档、项目的README、代码提交记录等所有项目相关的文字描述。团队合作的项目，实在找不到一个合适的理由不去把项目文档写好。不多说了。 后端接口规范这一点同样可以展开说很多。总结起来就一句话：需要一个良好的规范并去遵守它。 新增需求产品开发过程中，可能会新增需求。出现这种情况是正常的，但是需要开发人员灵活的去应对。小的需求可以考虑顺手做掉，大的改动/新增则需要叫上相关的同事一起讨论一下，看看是否有必要对项目的上线时间进行重新的评审。重新评审倒不是说项目上线一定要延期，而是为了大家一起把项目的风险降到最低。再开一次需求评审的另一个好处是，可以推动产品同事后续的需求考虑的更完善。 测试环境在立项之初，项目开发完成后测试环境、测试账号、测试用例等事情要准备好。其中细节会牵扯到很多，比如：如何保证测试环境和生产环境是一致的？是否有必要有了测试环境再去新增一个预发布环境？测试环境如果涉及到支付、依赖于特定环境（比如：微信）的文件上传该去如何测试？ 前端的工程化最后一点试会上没有提到的，但是我认为是有利于今后项目研发效率提升的。比如：同一个产品线设计规范的沉淀和输出（有了设计师的规范，前端可以去做 UI 库）、基础组件/业务组件的复用、开发工作流的完全自动化、前后端的完全分离等。 最后以上这些思考的角度并不新颖，毕竟太阳底下没有新鲜事。可能很多做软件开发的同学或多或少都有接触过这些事情，但是接触过、了解过、做过不代表做的足够好。每每遇到这种类似于“道理听过许多，却依旧过不好这一生”的情形时，我总是能想起于四个字：知行合一，然后会更深层次的理解这四个字。 修行在路上。Peace。]]></content>
      <tags>
        <tag>项目经验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在使用 hash 模式路由的单页面应用实现登录跳转]]></title>
    <url>%2F2017%2F06%2F08%2Flogin-for-spa-with-hash-model-router%2F</url>
    <content type="text"><![CDATA[问题描述SPA 在项目架构上通常需要一个用户系统，当用户使用这个应用时，会涉及到登录这个动作。 如果 SPA 应用无法做服务端渲染，那么在实现其路由模块时，使用 hash 模式会是一个常见的选择。 使用 hash 模式有一个问题是：服务端是无法获取 # 后面的内容的。这种特性会导致：当用户首次进入的是 host#/me/edit 之类的页面时，如果是服务端做登录的重定向跳转，会导致 #/me/edit 丢失，从而用户登录成功后，访问的页面的 url 是 host。 解决方案重定向到登录页面这件事情交给前端来负责。在跳转登录页之前，将 location.href 进行 base64 编码，将转码后内容传给后端，用于后端登录成功后重定向到用户最开始访问的页面。]]></content>
      <tags>
        <tag>SPA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[领域专用语言 DSL]]></title>
    <url>%2F2017%2F06%2F07%2Fdomian-specific-language%2F</url>
    <content type="text"><![CDATA[参考 领域专用语言(DSL)迷思]]></content>
      <tags>
        <tag>DSL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[推广 App 的最终目的是什么？]]></title>
    <url>%2F2017%2F06%2F01%2Fapp-promotion%2F</url>
    <content type="text"><![CDATA[今天的站立会上市场推广的伙伴提出一个问题：iOS App 的安装包有近 40M，在进行地推等推广时由于安装包较大，用户的成功安装率较低。 由于 iOS App 是用 Swift 编写的，天生就要比使用 Objective-C 编写的应用安装包体积大 10M 左右。加之目前的安装包大小已经经过 iOS 开发同学进行过一轮瘦身（减少了近 20M），所以目前再次进行瘦身的难度较大。 当然，也不是没有继续瘦身的办法。比如： 再次对使用的图片资源进行删减/压缩 对使用的一些第三方库进行删除/替换 一些静态资源变为 App 安装后加载并缓存 一些页面改为 Hybrid/ReactNative/Weex 方式实现 编译阶段再次尝试深度优化 这样的一个安装包体积大小的问题，让我想到：既然 App 推广成本这么大，为什么不考虑推广其他形式的产品呢？比如：基于微信服务号的 Web App、微信小程序。 显然，推广 App 是经过深思熟虑、利大于弊的选择。我尝试去思考这样决定的原因。作为一个商业组织，任何一个决定的最终目的应该是盈利。但如果仅把这个原因作为理由，内心深处是认可的但又有些“羞”于接受。这个理由太过于赤裸了。那是为了达到某些业务相关的指标吗？可是如果是为了指标，当下阶段显然选择 Web App、微信小程序更合适。 思考了一会儿，还是没有找到答案。我便把问题发到了部门的开发团队微信群中。不一会儿，群中就有了一些伙伴们的答案。观点大致分为两种： 为了某些业务指标 为了盈利 看到大家的答案，并没有让我满足。总感觉还差了些什么。 困惑之际，听到有人问坐在对面的军树：你是小帅吗？猛然抬头，少楠已坐在我的旁边。 少楠首先很直接给出的第一个原因：做这件事情的最终目的肯定是为了盈利的。当这些话略过耳边时，仿佛午后阳光狠狠地打在自己的脸颊，亦或是被轻风掠走了遮盖在脸上的最后一层面纱，内心的声音是：对，这就是根本的目的啊。有什么不敢于承认呢。商业的本质本是如此。 第二个原因是：从资本市场的角度来看，当下的智能手机环境，资本是更倾向于原生的 App 的。虽然苹果大爷有的时候也会心情不好，但总比基于微信更让人安心。当然，大的环境是在变化的。倘若有一天，微信的体量变得更大，不排除会把更多的资源投入到基于微信平台的应用的推广上。 第三个原因：目前原生 App 的用户体验确实是最好的。消息推送等能力更灵活、更强大。当 App 有了可观的数据后，未来成功的可能性就会随之变大。听到这个观点时，突然想到上午再次领悟到的一个词：平台。只有自家的基于操作系统级别的 App 才更容易往平台化去发展。 听到这三个观点后，心中豁然开朗。 我在想，内心变得充盈轻快不仅仅是因为解决了心中的一个困惑，而是因为这样的一次思考和交流影响了自己：要多去思考、多去见识，然后看问题尽可能从多个角度、多个层次。 最后，感谢少楠。 补充： 两条关于本文的评论： 更好的用户体验、不受平台限制的自主功能扩展，细粒度的用户行为数据积累，都是 App 的优势。 — 丁香园 叮当叔 个人认为，app用户粘度，留存会更高一点，推广性价比高。webapp需要收藏，小程序又没有变现渠道只能是工具，综合考虑有开发能力还是app更好。或许以后pwa,amp之类的能改善这一情况吧。 个人认为，app用户粘度，留存会更高一点，推广性价比高。webapp需要收藏，小程序又没有变现渠道只能是工具，综合考虑有开发能力还是app更好。或许以后pwa,amp之类的能改善这一情况吧。 — 网易邮箱前端工程师 吴少]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20170527]]></title>
    <url>%2F2017%2F05%2F27%2F20170527%2F</url>
    <content type="text"><![CDATA[希望尽量系统化的解决问题，避免让开发人员进行很多临时性的修复，这样系统也不够健壮。 工作周报/日报中最好要有个人的收获和思考。 日常的 bug 建议就不用写到邮件里面了，因为这些内容过于琐碎。作为一个开发工程师/产品汪，站在所有收到你邮件的人的角度想想，你这封邮件，对点开的人来说，写什么才更有价值呢？ 以后不要熬夜做测试，过于忙碌会导致没有时间思考。]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于减肥必须要知道的事情]]></title>
    <url>%2F2017%2F05%2F24%2Flose-weight%2F</url>
    <content type="text"><![CDATA[减肥过程中，比「体重」更重要的是什么减重不等于减肥，如何确保减掉的是脂肪运动在减肥中的真相，让你大吃一惊减肥过程中膳食的重要法则]]></content>
      <tags>
        <tag>减肥</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker 学习笔记]]></title>
    <url>%2F2017%2F05%2F15%2Fdocker%2F</url>
    <content type="text"><![CDATA[容器是一种历史悠久的虚拟化技术。Linux 的 LXC、Solaris 上的 Zones等，都是容器的不同实现方式。 一个容器实质上就是运行在宿主机上的一个进程。只不过在启动进程之前，进行了一些特殊处理，让这个进程进入了一个全新的虚拟环境，与宿主机环境分开。所以这个进程以及它的子进程认为自己运行在一个独立的世界里面。 简介Docker 是一个能够把开发的应用程序自动部署到容器的轻量级的容器管理引擎。 提供一个简单、轻量的建模方式。大多数 Docker 应用程序只需要不到 1 秒钟即可启动。 职责的逻辑分离。使用 Docker，开发人员只需要关心容器中运行的应用程序，而运维人员只需要关心如何管理容器。 快速、高效的开发生命周期。Docker 的目标之一就是缩短代码从开发、测试到部署、上线运行的周期，让你的应用程序具备可移植性，易于构建，并易于协作。 鼓励使用面向服务的架构和微服务架构 核心组件 Docker 的客户端和服务端，也称为 Docker 引擎 Docker 镜像 Registry Docker 容器 镜像和仓库什么是 Docker 镜像？Docker 镜像是由文件系统叠加而成。最低端是一个引导文件系统，即 bootfs，这很像典型的 Linux/Unix 的引导文件系统。Docker 用户几乎永远不会和引导文件系统有什么交互。实际上，当一个容器启动后，它将会被移到内存中，而引导文件系统则会被写在（unmount），以留出更多的内存供 initrd 磁盘镜像使用。 到目前为止，Docker 看起来还很像一个典型的 Linux 虚拟化栈。实际上，Docker 镜像的第二层是 root 文件系统 rootfs，它位于引导文件系统之上。rootfs 可以是一种或多种操作系统。 为了区分一个仓库中的不同镜像，Docker 提供了一种称为标签（tag）的功能。 构建镜像有两种方式： 使用 docker commit 命令 使用 docker build 命令和 Dockerfile 文件 后者更灵活、更强大。 一般来说，我们不是真正的创建新镜像，而是基于一个已有的基础镜像，如 Ubuntu 或 fedora 等，构建新镜像而已。 常用命令1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980# Docker 相关的信息docker info# 查看帮助文档docker help# 查看某个命令的使用文档docker COMMAND --help# 创建并运行新容器 # -i 保证容器中 STDIN 是开启的# -t 告诉 Docker 为要创建的容器分配一个伪 tty 终端，这样新创建的容器才能提供一个交互式 shell# eg. docker run -i -t ubuntu /bin/bash# --name 为容器指定一个名词# eg. docker run --name try_name_ubuntu -i -t ubuntu /bin/bash# --restart 让 Docker 自动重新启动该容器docker run [OPTIONS] IMAGE [COMMAND] [ARG...]# 查看运行中的容器# -a 查看所有状态下的容器列表# -l 查看最后一个运行的容器docker ps# 查看容器的详细信息docker inspect [OPTIONS] NAME|ID [NAME|ID...]# 重新启动已经停止的容器docker start NAME|ID# 附着到容器上docker attach [OPTIONS] CONTAINER# 创建一个容器docker create [OPTIONS] IMAGE [COMMAND] [ARG...]# 获取守护式容器的日志# 可通过 Ctrl + C 退出日志跟踪docker logs [OPTIONS] CONTAINER# 查看容器内的进程docker top CONTAINER [ps OPTIONS]# 在容器内额外启动新进程# 可以在容器内运行的进程有两种类型：后台任务和交互式任务。# 后台任务在容器内运行且没有交互需求，而交互式任务则保持在前台运行。# 对于需要在容器内打开 shell 的任务，交互式任务是很实用的。# -d 表明需要运行一个后台进程docker exec [OPTIONS] CONTAINER COMMAND [ARG...]# 查看 Docker 统计信息docker stats# 停止守护式容器docker stop [OPTIONS] CONTAINER [CONTAINER...]# 删除容器docker rm [OPTIONS] CONTAINER [CONTAINER...]# 删除镜像docker rmi [OPTIONS] IMAGE [IMAGE...]# 删除所有容器docker rm `docker ps -a -q`# 列出本机已有的 Docker 镜像docker images# 拉取镜像docker pull [OPTIONS] NAME[:TAG|@DIGEST]# 查找镜像docker search [OPTIONS] TERM# 从 PATH 中的源码构建镜像 # 通常会使用 -t 参数。eg. docker build -t="lizy/static_web:v1.0.0" .# --no-cache 用来指定构建的时候不使用缓存docker build [OPTIONS] PATH | URL | -# 查看容器端口映射情况docker port CONTAINER [PRIVATE_PORT[/PROTO]] Dockerfile简介Dockerfile 使用基本的基于 DSL（Domain Specific Language）语法的指令来构建一个 Docker 镜像。Dockerfile 由一系列指令和参数组成。每条指令都必须为大写字母，且后面要跟随一个参数。Dockerfile 中的指令会按顺序从上到下执行，所以应该根据需要合理的安排指令的顺序。 每个 Dockerfile 的第一条指令必须是 FROM。FROM 指令指定一个已经存在的镜像，后续指令都将基于该镜像进行，FROM 指令指定的镜像被称为基础镜像（base image）。 Dockerfile 中指令执行流程每条指令都会创建一个新的镜像并对新的镜像进行提交。大体流程如下： Docker 从基础镜像运行一个容器 执行一条指令，对容器做出修改 执行类似 docker commit 的操作，提交一个新的镜像 Docker 再基于刚提交的镜像运行一个容器 执行 Dockerfile 中的下一条指令，直到所有指令都执行完毕 Dockerfile 指令FROM指定一个已经存在的镜像 MAINTAINER告诉 Docker 该镜像的作者是谁，以及作者的电子邮件地址。 ENV在镜像中设置环境变量。 RUN在当前镜像中运行指定的命令。 EXPOSE告诉 Docker 该容器内的应用将会使用容器的指定端口。 这并不意味着可以自动访问任意容器运行中服务的端口。处于安全的考虑，Docker 并不会自动打开该端口，而是用户在使用 docker run 运行容器是来指定需要打开哪些端口。 可以指定多个 EXPOSE 指令来向外部公开多个端口。 构建上下文我们会创建一个目录来保存 Dockerfile，这个目录是我们的构建环境（build environment），Docker 则称此环节为上下文（content）或者构建上下文（build content）。 .dockerignore用来设置那些文件不会被当做构建上下文的一部分。 docker run -d -p 80 –name static_web lizy/static_web:v1 nginx -g “daemon off;” 实践在宿主机上启用 Nginx1docker pull nginx Is it possibe to answer dialog questions when installing under docker?-Unable to initialize frontend: dialog when using ssh]]></content>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017-eleme-fe-share-meeting]]></title>
    <url>%2F2017%2F05%2F06%2F2017-eleme-fe-share-meeting%2F</url>
    <content type="text"><![CDATA[PWAhttps://h5.ele.me/msite/ 前后端协作方式的演进与探索http://mockjs.com/ https://www.easy-mock.com/]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[作为前端开发，你了解 viewport 吗？]]></title>
    <url>%2F2017%2F04%2F01%2Fviewport%2F</url>
    <content type="text"><![CDATA[在之前的文章延迟，让你更幸福了吗？一文中，说明了解决移动端浏览器点击事件延迟的方法，其中提到了 viewport 元标签。viewport 通常被称作视口（视窗 ），是指设备的屏幕上能用来显示网页的那一块区域。简单的说，viewport 是严格等于浏览器的窗口的。在桌面浏览器中，viewport 就是浏览器窗口的宽度高度。但在移动端设备上就有点复杂。下面，我们就来仔细的聊一聊 viewport。 viewport 的由来viewport 元标签不是任何 web 标准的一部分。Mobile Safari 引入了 viewport 元标签来让 web 开发者控制视口的尺寸及比例。目前这种做法被绝大多数流行的移动浏览器所支持、被成千上万的站点所使用。 设备像素（device pixel） 和 CSS 像素（css pixel）想弄清楚viewport，我们需要先了解设备像素、CSS 像素以及两者之间的差异。 设备像素是物理概念，指的是设备中使用的物理像素。设备像素给出了任何设备的正式分辨率，比如 iPhone 5 的分辨率为 640 x 1136px。每个像素可以根据操作系统设置自己的颜色和亮度。正是这些设备像素的微小距离欺骗了我们肉眼看到的图像效果。 CSS 像素是 Web 编程中的概念，指的是 CSS 样式代码中使用的逻辑像素，主要用来精确度量Web页面上的内容。在 CSS 规范中，长度单位可以分为两类，绝对(absolute)单位以及相对(relative)单位。px 是一个相对单位，相对的是设备像素(device pixel)。一般情况之下，CSS 像素称为与设备无关的像素(device-independent pixel)，简称 DIPs。 设备像素与 CSS 像素的换算这就需要要谈到每英寸像素和设备像素比。 每英寸像素/屏幕密度（PPI/DPI, pixel per inch）表示每英寸所拥有的设备像素(pixel)数目，数值越高，代表显示屏能够以越高的密度显示图像。PPI 的计算方式可以参考维基百科每英寸像素 密度无关像素（density-independent pixel）/设备独立像素（device-independent pixel）设备独立像素也称为密度无关像素，可以认为是计算机坐标系统中的一个点，这个点代表一个可以由程序使用的虚拟像素(比如说CSS像素)，然后由相关系统转换为物理像素。 设备像素比（DPR, device pixel ratio）以上计算出 PPI 是为了得到屏幕密度分界，获得默认缩放比例，即设备像素比。 设备像素比 ＝ 物理像素 / 设备独立像素 在JavaScript中，可以通过window.devicePixelRatio获取到当前设备的dpr。 由上图可知，PPI 在120-160之间的手机被归为低密度手机，160-240被归为中密度，240-320被归为高密度，320以上被归为超高密度（有研究表明，人类肉眼能够分辨的最高像素点密度是 300 每英寸像素。超过300每英寸像素的屏幕被常常称为Retina 显示屏，这个概念最早由苹果公司于 2010 年推出 iPhone4 手机的时候提出）。 如何获取设备像素（屏幕尺寸）？通常我们可以从 BOM(Browser Object Model) 中通过 screen.width/screen.height 获取。 如何获取窗口尺寸？如果你想知道用户访问的页面中有多少空间可以用来 CSS 布局，那么你需要获取浏览器窗口的内部尺寸。可以通过window.innerWidth/window.innerHeight来获取这些尺寸。注意度量的宽度和高度是包括滚动条的。它们也被视为内部窗口的一部分。（这大部分是因为历史原因造成的。） 如何获取 HTML 文档的尺寸？可见宽度：document.documentElement.clientWidth 实际宽度：document.documentElement.offsetWidth 实际上，document.documentElement指的是 &lt;html&gt; 元素：即任何HTML文档的根元素。 layout viewport 和 visual viewport当我们比较移动浏览器和桌面浏览器的时候，它们最显而易见的不同就是屏幕尺寸。当我们打开一个未针对移动端做任何 CSS 适配的页面时，我们会不由的慨叹：viewport 太窄了！viewport 并不能按照写给桌面浏览器的 CSS 正确布局。明显的解决方案是使 viewport 变宽一些。聪明的人们想到了一个解决办法：把 viewport 分成两部分：visual viewport和layout viewport。 两个 viewport 都是以 CSS 像素度量的。但是当进行缩放（如果你放大，屏幕上的 CSS 像素会变少）的时候，visual viewport 的尺寸会发生变化，layout viewport 的尺寸仍然跟之前的一样。 George Cummins在Stack Overflow上对基本概念给出了最佳解释： 把layout viewport想像成为一张不会变更大小或者形状的大图。现在想像你有一个小一些的框架，你通过它来看这张大图。（译者：可以理解为「管中窥豹」）这个小框架的周围被不透明的材料所环绕，这掩盖了你所有的视线，只留这张大图的一部分给你。你通过这个框架所能看到的大图的部分就是visual viewport。当你保持框架（缩小）来看整个图片的时候，你可以不用管大图，或者你可以靠近一些（放大）只看局部。你也可以改变框架的方向，但是大图（layoutviewport）的大小和形状永远不会变。 我们工作中所谓的 CSS 布局，尤其是百分比宽度，是以 layout viewport 做为参照系来计算的，它被认为要比 visual viewport 宽。即：&lt;html&gt; 元素在初始情况下用的是 layout viewport 的宽度，这使得站点布局的行为与其在桌面浏览器上的一样。 layout viewport有多宽？每个浏览器都不一样。Safari iPhone为980px，Opera为850px，Android WebKit为800px，最后IE为974px。 如何获取两个 viewport 的宽度？如果理解了上面讲述的内容，不难理解下面获取 viewport 的方式： layout viewport: document.documentElement.clientWidth/document.documentElement.clientHeight visual viewport: window.innerWidth/window.innerHeight 缩放比例（zoom level）直接读出缩放比例是不可能的，但是你可以通过以 screen.width/window.innerWidth 来获取它的值。当然这只有在两个属性都被完美支持的情况下才有用。 viewport meta 的详细作用 Name Value Description width 正整数或device-width 定义视口的宽度，单位为像素 height 正整数或device-height 定义视口的高度，单位为像素 initial-scale [0.0-10.0] 定义初始缩放值 minimum-scale [0.0-10.0] 定义缩小最小比例，它必须小于或等于maximum-scale设置 maximum-scale [0.0-10.0] 定义放大最大比例，它必须大于或等于minimum-scale设置 user-scalable yes/no 定义是否允许用户手动缩放页面，默认值yes 在移动端 web 应用开发过程中，常用的设置为： 123&lt;meta name="viewport" content="width=device-width"&gt;&lt;meta name="viewport" content="user-scalable=no"&gt;&lt;meta name="viewport" content="initial-scale=1,minimum-scale=1,maximum-scale=1"&gt; 还有一种常用的写法，就是根据自己设备的dpr来还原设备本来宽度，如假设手机devicePixelRatio为2，则设置 12&lt;meta name="viewport" content="user-scalable=no"&gt;&lt;meta name="viewport" content="initial-scale=0.5, maximum-scale=0.5, minimum-scale=0.5"&gt; 详情可参考延迟，让你更幸福了吗？ 阿里 flexible.js 的原理flexible.js 的一生只做了三件事： 动态改写 &lt;meta&gt; 标签 给 &lt;html&gt; 元素添加 data-dpr 属性，并且动态改写 data-dpr 的值 给 &lt;html&gt; 元素添加 font-size 属性，并且动态改写 font-size 的值 flexible 本质上就是通过 JavaScript 来动态改写 meta 标签。在正确引入 flexible.js 后，会在 &lt;html&gt; 元素上增加一个 data-dpr 属性，以及一个 font-size 样式。JavaScript 会根据不同的设备添加不同的 data-dpr 值，比如说 2 或者 3，同时会给 &lt;html&gt; 加上对应的 font-size 的值，比如说75px。 如此一来，页面中的元素，都可以通过 rem 单位来设置大小。他们会根据 html 元素的 font-size 值做相应的计算，从而实现屏幕的适配效果。 实际上，如果仅需要做到适配移动端页面，只需要动态改变 &lt;html&gt; 元素上的 font-size 样式即可。那么为什么 flexible.js 会在 &lt;html&gt; 元素上增加一个 data-dpr 属性呢？原因如下： 我们不希望文本在Retina屏幕下变小，另外，我们希望在大屏手机上看到更多文本，以及，现在绝大多数的字体文件都自带一些点阵尺寸，通常是16px和24px，所以我们不希望出现13px和15px这样的奇葩尺寸。 如果 &lt;html&gt; 元素有了 data-dpr 属性，实现对文本字体的单独设置就变得很轻松。只需要如下代码： 1234567891011div &#123; width: 1rem; height: 0.4rem; font-size: 12px; // 默认写上dpr为1的fontSize&#125;[data-dpr="2"] div &#123; font-size: 24px;&#125;[data-dpr="3"] div &#123; font-size: 36px;&#125; 注： 在 Flexible 中，只对 iOS 设备进行 dpr 的判断，对于 Android 系列，始终认为其 dpr 为 1。 移动端适配该怎么做？页面布局： 基于 CSS 盒模型、绝对/相对定位、元素浮动的传统流式布局 Flex 布局 Grid 布局 具体页面元素的大小： 限定元素高度，元素宽度 auto 基于/类似手淘的 flexible.js，使用 rem 目前，笔者仅在一个 web app 项目中使用了类 flexible.js 的方案。 坦白的说，我对每种方案没有特别的喜好。我的移动端适配的思路为：灵活运用各种技术手段，在达到自己和产品经理都满意的效果基础上，尽可能的给用户最好的视觉体验即可。 最后设计师和前端工程师之间的设计稿如何协同呢？ 一般由设计师按照设备像素为单位制作设计稿。前端工程师参照相关的设备像素比，进行换算以及编码。 参考 在移动浏览器中使用viewport元标签控制布局 A tale of two viewports — part one A tale of two viewports — part two 前端工程师需要明白的「像素」 移动终端开发必备知识 使用Flexible实现手淘H5页面的终端适配]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我眼中的前端]]></title>
    <url>%2F2017%2F03%2F31%2Fthe-front-end-of-my-eyes%2F</url>
    <content type="text"><![CDATA[早就想以“我眼中的前端”为题写一篇文章了，可却迟迟没有动笔。因为总是觉得冥冥之中自己还没有触及到前端的边界。 今天是 2017 年的第一季度最后一天，元旦之后开始参与的来问丁香医生项目重构版本发布上线并趋于稳定，参与的丁香医生 App v6.0 成功上线且后续版本迭代开发顺利，最近几天大概了解到第二季度自己会参与其中的事情，走在回家路上时突然想到：尝试着去写一下吧！如果写的不好，那就继续沉淀一段时间再写一次。 第一次正式接触前端相关的知识，是在大二的时候。那时候有一门专业课，名字大概叫做企业级系统设计。授课内容主要是 J2EE 相关的内容。依稀记得老师讲到 JSP 时，对我们说 HTML、CSS 这些内容很简单的，你们课后回去自己看一下就好了。当时的我，从“冰冷的” VC 6.0 编译代码后黑乎乎的命令行窗口逃离没有多久，还沉浸在遇到 Eclipse 的喜悦之中，对前端产生的第一印象是：简单。当看到自己写的页面，在浏览器中真真切切的按照自己的意愿展示出来时，对前端产生的印象是：有趣。 于是乎就选修了学校的公选课：网页设计与制作，在那里学习到了 PS 的一些基本操作。再后来在 QQ 空间看到学校有一个叫做工大开发者联盟的社团，将要举办培训班，便去试听了前端和安卓两个班，最终选择了前端方向，在这期间自己对 JavaScript 这门语言有了新的认识。 大三下学期找实习工作时，来学院宣讲的几乎都是招聘 Java、C++ 的，加上自认为 Java 学的比 C++、C# 好一些，便做了一份应聘 Java 实习生的简历。就在笔试和面试了几家公司等结果时，学院来了一家创业公司进行宣讲。当海归、创业、微软谷歌背景、硅谷从业经历、H5、云平台这些词从宣讲者口中说出来时，感觉自己已经被点燃了：这就是我想去的公司啊！投简历、笔试、面试一切进行的都还顺利。签过实习协议后，公司给发了一封邮件，要求入职前去深入学习 JavaScript，并推荐了《JavaScript 高级程序设计》、《JavaScript 权威指南》等学习资料，正是这段期间自己第一次系统的学习了JavaScript。2014 年 8 月 23 日，一个朝气蓬勃的少年，踏上了前端开发的征程。 从最开始接触 HTML 至今，一路跌跌撞撞近五年的时间了。下面尝试从一些维度来写一写“我眼中的前端”。 关于前端项目类别和前端开发技术栈两个部分，展开说的话可以写很多，由于希望赶在第二季度到来之前写完这篇文章，加之感冒了状态不佳，遂暂时放两张思维脑图。今后会单独写写这两个话题。 前端项目类别 PS. 把 App 开发也列为了前端，希望做 iOS 开发和 Android 开发的伙伴们不要介意。我知道原生 App 开发的水是很深的，这方面的知识有机会我还是要学习一个。不过，在我的认知中，一切跟用户直接打交道并依赖于服务端数据供给的软件应用，都可以被称为前端。 前端开发技术栈 PS. 有些我认为如果不出意外的话，不会再在新的项目中使用的前端技术被我略掉了。 前端开发过程中的一些挑战写到这一点时，我的思绪有些停顿。做了这么久的前端开发，目前觉得稍可以算上有点挑战的事情有： 数据(应用状态)的管理 浏览器兼容 前者指的是那种“前端很重”的应用，比如 Teambition 这种；后者说其有挑战，主要是因为这是一件充满不确定性且永远做不完的事情。 目前工作中觉得有挑战的几件事： 前端项目异常的监控、上报与通知 Hybrid 应用中前端资源的分发和增量更新 H5 运营活动的工程化 需要自己不断探寻边界、去挑战的方向：服务端开发、运维等。 写到这里，透露出我关于前端的另一个认知：如果以整个软件项目的角度来衡量，除了最贴近数据库那一层的很基础很“底层”的接口外，业务级别的接口封装、用户系统的设计与实现、整个服务端的安全和运维等工作，都可以说为是前端领域的工作内容。 前端的本质这篇文章丝毫没有冒犯移动端开发和服务端开发之意。 我认为现在人们常提起的前端开发、移动端开发、服务端开发都只是软件工程的一个细分，它们彼此需要紧密配合，并肩作战，最终才可以良好的支撑各种商业行为的运作。从服务端获取到数据的那一刻起，前端便有了生命力。前端的使命就是控制数据准确的流动，尽可能给用户最棒的使用体验。而一旦有了数据的流动，就会出现不同维度的复杂度，此时就需要前端开发者撸起袖子，奋勇拼搏，最终交上一份让自己、团队都满意的答卷。 前端的本质应该是什么呢？暂时我还给不出准确的答案。暂且引用一句去年在阿里 D2 大会上看到的一句话吧：链接商业、设计、计算能力，为用户提供专业的人机交互体验。 前端工程师应该具备的素质写了这么多，那么我眼中的前端工程师，应该具备怎样的素质呢？ 扎实的技术功底 良好的沟通能力 良好的表达能力 较强的团队合作意识 冷静、快速解决问题的能力 Owner 的心态 开阔的技术视野 有一定的技术追求 （为人）可信赖的（负责的项目）可依赖的 还有想写的吗？前端是一个太宽泛的话题了。之后或许会尝试把这篇文章中的某一个点拎出来，单独来谈一谈。行文间流露着匆忙之意，不过也到此为止吧。 再写一句话作为结束语吧：世上本没有前端，做的人多了也就。。。 写于 2017 年 3 月 31 日夜]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[learn-pwa]]></title>
    <url>%2F2017%2F03%2F21%2Flearn-pwa%2F</url>
    <content type="text"><![CDATA[If the web doesn’t do something today it’s not because it can’t, or won’t,but rather it is because we haven’t gotten around to implementing that capability yet. TODO]]></content>
      <tags>
        <tag>PWA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu 基本使用]]></title>
    <url>%2F2017%2F03%2F14%2Fubuntu%2F</url>
    <content type="text"><![CDATA[常用命令1234567891011121314# 更新软件源sudo apt-get update# 添加一个新用户adduser username# 查看主机名hostname# 查看进程ps -aux# 查看 Ubuntu 版本cat /etc/issue 安装 curl1apt-get install curl 安装 Nginxapt-get 安装1sudo apt-get install nginx 使用12345# 启动sudo /etc/init.d/nginx start# 停止sudo /etc/init.d/nginx stop Ubuntu安装之后的文件结构大致为： 所有的配置文件都在/etc/nginx下，并且每个虚拟主机已经安排在了/etc/nginx/sites-available下 程序文件在/usr/sbin/nginx 日志放在了/var/log/nginx中 已经在/etc/init.d/下创建了启动脚本nginx 默认的虚拟主机的目录设置在了/var/www/nginx-default (有的版本 默认的虚拟主机的目录设置在了/var/www, 请参考/etc/nginx/sites-available里的配置) 编译安装准备工作123456sudo apt-get updatesudo apt-get install build-essentialsudo apt-get install libtool# 选定源码目录（可以是任何目录，本文选定的是/usr/local/src）cd /usr/local/src 安装 PCRE 库一般我们都需要先装pcre, zlib，前者为了重写rewrite，后者为了gzip压缩。 todo… 安装 Node.jsapt-get 安装以 Node v8.x 为例： 123curl -sL https://deb.nodesource.com/setup_8.x | sudo -E bash -sudo apt-get install -y nodejssudo apt-get install -y build-essential 编译安装1234567891011121314151617181920212223242526272829303132# 前提（确保安装了 curl 和 python）apt-get install build-essential libssl-dev# 创建一个用来存放下载的 Node.js 源码的临时文件夹mkdir temp# 进入临时文件夹cd temp# 下载 Node 源码压缩包curl -O http://nodejs.org/dist/node-latest.tar.gz# 解压 Node 源码tar zxvf node-latest.tar.gz# 进入解压后的 Node 文件夹cd node-v7.x# 运行配置脚本./configure# 编译make# 安装make install# 安装成功后查看 Node 版本node -v# 删除 temp 文件夹rm -rf temp/ Mongodb安装1234567apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv 0C49F3730359A14518585931BC711F9BA15703C6echo "deb [ arch=amd64,arm64 ] http://repo.mongodb.org/apt/ubuntu xenial/mongodb-org/3.4 multiverse" | tee /etc/apt/sources.list.d/mongodb-org-3.4.listapt-get updateapt-get install -y mongodb-org 使用在 Docker 中启动docker本身就相当于服务。所以 Mongodb 软件本身必须前台运行（相对于docker）。 12345# 启动mongod# 启动并返回终端mongod &amp; 安装 Yarn1234567curl -sS https://dl.yarnpkg.com/debian/pubkey.gpg | sudo apt-key add -echo "deb https://dl.yarnpkg.com/debian/ stable main" | sudo tee /etc/apt/sources.list.d/yarn.listapt-get updateapt-get install yarn 安装 Git1apt-get install git 安装 Docker准备工作1234567891011121314151617181920212223242526272829sudo apt-get update# 允许 Docker 使用 aufs 存储驱动程序sudo apt-get install \ linux-image-extra-$(uname -r) \ linux-image-extra-virtual# 安装软件包以允许通过 HTTPS 使用存储库sudo apt-get install \ apt-transport-https \ ca-certificates \ curl \ software-properties-common# 添加 Docker 的官方 GPG 密钥curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -# 使用以下命令设置稳定版本库。始终需要稳定的存储库，即使也想安装最新发布版本。# amd64:sudo add-apt-repository \ "deb [arch=amd64] https://download.docker.com/linux/ubuntu \ $(lsb_release -cs) \ stable"# armhf:sudo add-apt-repository \ "deb [arch=armhf] https://download.docker.com/linux/ubuntu \ $(lsb_release -cs) \ stable" 安装 Docker12sudo apt-get updatesudo apt-get install docker-ce 参考 Nginx 运维与架构 Install MongoDB Community Edition on Ubuntu Debian and Ubuntu based Linux distributions]]></content>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web 前端性能优化]]></title>
    <url>%2F2017%2F03%2F13%2Ffe-performance-optimization%2F</url>
    <content type="text"><![CDATA[《高性能网站建设指南》读书笔记 绪言前端性能的重要性跟踪 Web 页面性能为了知道能够改进哪些地方，我们需要了解用户的时间都花在等待哪些东西上了。 性能黄金法则 只有10%~20%的最终用户响应时间花在了下载 HTML 文档上，其余80%~90%的时间花在了下载页面中的所有组件上。 HTTP（Hyper Text Transfer Protocol）概述HTTP 是一种客户端/服务器协议，由请求和协议构成。浏览器想一个特定的 URL 发送 HTTP 请求，URL 对应的宿主服务器发回 HTTP 响应。该协议使用简单的纯文本格式。]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈前端项目的重构]]></title>
    <url>%2F2017%2F03%2F12%2Fupgrade-and-refactoring-of-a-fe-project%2F</url>
    <content type="text"></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何带好新人]]></title>
    <url>%2F2017%2F03%2F10%2Fhelp-new-people%2F</url>
    <content type="text"><![CDATA[参加范老师【如何带好新人】培训笔记 新员工刚入职的规律生死期前两周和第一个月 前两周：基本决定了员工对公司的印象 第一个月：决定了员工是否留下来和未来工作基本面 融入感是否融入团队可感知 墨菲定律入职前两周如果适应的好，就会融入的很好 入职前两周如果出现不适，接下来必出问题 入职第一个月请假达三次的必走无疑 融入信号 放松 主动 和团队在一起的协调感，不会感觉别扭 如何带好新员工入职培训明规则公司人事和行政制度以及明文规定 潜规则什么是鼓励的行为，什么是不鼓励的行为 喂饱喂足提前准备饱和的任务 每周迭代以周为单位管理 每周为新员工制定详细的本周工作任务 每周检查工作任务完成情况 第一周做到每天检查工作任务 指明方向找到方向感和自我定位 将团队今年的工作计划告诉员工，让员工清楚自己该做什么和怎么做，让他清楚自己的努力方向。 思想教育勿以善小而不为 要教育新员工做事情要沉住气 集体活动功夫在诗外 还要注意什么新人渴望帮助及时发现和帮助解决困难 新人任务明确任务安排具体明确可落实 新人需要思想工作关注情绪及时开导 新人也要定位准确因材施教安排适合的工作 新人不能纠结不合适的及时结束试用期 最后带新人需要你加倍的付出]]></content>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[延迟，让你更幸福了吗？]]></title>
    <url>%2F2017%2F03%2F03%2F300ms-delay-on-mobile-browsers%2F</url>
    <content type="text"><![CDATA[做前端开发的同学应该知道：在移动端使用了 WebKit 内核的浏览器上，单击操作会延迟 300ms（也有延迟 350ms 的说法，下文统称为 300ms 延迟）后再执行。 造成延迟的原因故事要从 2007 年第一场雪说起，当时的网站都是为大屏幕设备所设计的，苹果公司在发布首款 iPhone 前夕，遇到一个问题： 在用户使用像 iPhone 这种小屏幕设备的浏览器访问网站时，如何确保用户获得较好的浏览体验。苹果的工程师们做了一些约定来解决这个问题，其中一项约定便是双击缩放(double tap to zoom)：用手指在屏幕上快速点击两次，iOS 自带的 Safari 浏览器会将网页缩放至原始比例。 由于当用户一次点击屏幕之后，浏览器并不能立刻判断用户是确实要打开这个链接，还是想要进行双击操作。因此，iOS Safari 就等待 300ms，以判断用户是否再次点击了屏幕。 逐渐地，几乎现在所有的移动端浏览器都支持了双击缩放这个交互。 在人们还在为通过移动设备上网而惊叹的时期，没有人会在意这 300ms 的延时。而当移动互联网的浪潮滚滚而来时，对于 Web 开发人员来说，点击事件的快速响应变得非常重要。移动端浏览器上所有的单击事件都有 300ms 延迟这件事，开始被人们诟病。 解决延迟的方法有问题，就会有对应的解决办法，任何一件事都逃不出这个定律。300ms 延迟也不例外。 常用的解决方案如下： 禁用缩放 更改浏览器视口的默认宽度 指针事件 (Pointer Events) FastClick 禁用缩放这是一个比较容易想到的解决方案：既然延迟的起因是页面缩放，那就禁止页面缩放好了。 代码实现起来也很容易，只需要在 html 页面头部添加如下代码： 12&lt;meta name="viewport" content="user-scalable=no"&gt;&lt;meta name="viewport" content="initial-scale=1,minimum-scale=1,maximum-scale=1"&gt; 自古以来，“一刀切”是能解决问题的，但通常不是问题的最优解。 这个解决方案看似完美，但也带来一个明显的缺陷 —— 你必须完全禁用缩放来达到目的，而从移动端站点的可用性和可访问性来看，缩放是相当关键的一环。你很可能已经遇到过这个问题，即你想要放大一张图片或者一段字体较小的文本，却发现无法完成操作。 更改浏览器视口的默认宽度2014 年，Chrome 开发团队宣布，在 Chrome 32 这一版中，他们将在通过&lt;meta&gt;标签设置 width=device-width 或者置为比 viewport 值更小的页面上禁用双击缩放。页面禁用了双击缩放，就意味着没有了 300 ms点击延迟。 这个方法代码实现起来依旧很简单：只需要在 html 页面头部添加一行代码： 12&lt;!--使浏览器将视口大小设为设备本身的尺寸--&gt;&lt;meta name="viewport" content="width=device-width"&gt; 该方案只是禁用了双击缩放操作，用户依旧可以使用双指缩放(pinch to zoom)等操作与页面发生交互。缩放功能并非被完全禁用，也就不存在可用性和可访问性的问题了。 目前，主流的移动端浏览器均已支持该方案。 iOS 10 发布之后，通过 &lt;meta&gt; 标签设置的 user-scalable，min-scale 和 max-scale 会被 WebKit 忽略掉，这意味着 iOS 10 上的 Safari/Chrome 允许用户在每个页面上进行缩放。但是依旧可以通过使用 &lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1.0, width=device-width&quot;&gt; 来消除延迟，从而快速响应用户的单击操作。 在 iOS 10 的 hybrid 应用中，可以通过在 WKWebViewConfiguration 上设置新属性来阻止用户缩放： var ignoresViewportScaleLimits : Bool 默认值为 false ，这意味着 WKWebView 内容将允许内容阻止缩放。这保留了旧版本的 iOS 的行为。 实际上，正是因为 iOS 10 中的 Safari 和 SafariViewController 将值设置为 true，才会导致禁止页面缩放失效。 指针事件 (Pointer Events)除了使用 HTML 的 &lt;meta&gt; 标签禁止页面缩放外，我们还可以通过 CSS 的方式来让页面快速响应点击操作。该种方式在国内通常被称作：指针事件。 指针事件最初由微软提出。指针事件是一个新的 web 事件系列，相应的规范旨在使用一个单独的事件模型，对所有输入类型，包括鼠标 (mouse)、触摸 (touch)、触控 (stylus) 等，进行统一的处理。 指针事件方案中，有一个和点击延迟直接相关的实现：一个名为 touch-action 的新 CSS 属性。根据规范 touch-action 属性决定 “是否触摸操作会触发用户代理的默认行为。这包括但不限于双指缩放等行为”。 默认情况下，页面上的元素具有 touch-action: auto;，这表示 WebKit 可以启用任何触摸行为，例如平移，捏和双击。当页面上的元素具有 touch-action: manipulation; 时，WebKit 仅会支持在可点击元素上的触摸行为，仅用于平移和缩放的目的。 这味着 WebKit 不会考虑对元素执行双击手势，因此会立即调度单个点击。 当任何元素的祖先具有touch-action: manipulation; 时，元素上的单个点击变得快速。 注意，页面上所有具有了touch-action: manipulation;的节点的子节点都会立即调度单个点击事件。该种方式适用于各种缩放比例的页面。 关于 touch-action 具体详情,可访问W3C 规范的候选推荐标准阶段进行了解。 可以从http://caniuse.com/来了解现阶段各个浏览器对touch-action的支持情况。 指针事件的 polyfill下面列出了几种针对指针事件的 polyfill： Polymer HandJS Points 需要注意的是，如果你需要的仅仅是一个解决 300ms 点击延迟的方法，上述方案可能不是最理想的。因为它们要么是会影响页面整体性能的资源密集型的方案，要么是 touch-action 属性的非标准化模拟。 FastClickFastClick 是 FT Labs 专门为解决移动端浏览器 300 ms点击延迟问题所开发的一个轻量级的库。 实现原理FastClick 在检测到 touchend 事件的时候，会通过 DOM 自定义事件立即触发一个模拟 click 事件，并把浏览器在 300 ms之后真正触发的 click 事件阻止掉。 使用方法FastClick 的使用方法非常简单。官方推荐的使用方法为：当初始 HTML 文档已完全加载和解析时，调用 FastClick.attach(document.body);： 12345if ('addEventListener' in document) &#123; document.addEventListener('DOMContentLoaded', function() &#123; FastClick.attach(document.body); &#125;, false);&#125; 如果使用了 jQuery，可以使用如下方式使用 FastClick： 123$(function() &#123; FastClick.attach(document.body);&#125;); 如果使用了 npm 等模块化的方式安装了 FastClick，则可以按照如下方式使用： 12const attachFastClick = require('fastclick');attachFastClick(document.body); 其实具体如何使用 FastClick，去看一下 FastClick 的源码就一目了然了： 123456789101112if (typeof define === 'function' &amp;&amp; typeof define.amd === 'object' &amp;&amp; define.amd) &#123; // AMD. Register as an anonymous module. define(function() &#123; return FastClick; &#125;);&#125; else if (typeof module !== 'undefined' &amp;&amp; module.exports) &#123; module.exports = FastClick.attach; module.exports.FastClick = FastClick;&#125; else &#123; window.FastClick = FastClick;&#125; 值得注意的是：attach() 方法虽可在更具体的元素上调用，直接绑定到 &lt;body&gt; 上可以确保整个应用都能受益。当 FastClick 检测到当前页面使用了基于 &lt;meta&gt; 标签或者 touch-action 属性等解决方案时，会静默退出。可以说，这是真正的跨平台方案出来之前一种很好的变通方案。 移动端浏览器的现状目前 iOS 和 Android 两大平台的移动设备上的浏览器，以及两个平台上微信中的内置浏览器均可通过上述方案来解决 300 ms 延时问题。 备注目前各个浏览器使用的内核情况。 浏览器 内核 Safari WebKit Chrome WebKit Opera WebKit Firefox Gecko 国产浏览器极速模式 WebKit 微信浏览器 WKWebView 参考 FastClick 300ms tap delay, gone away 300 ms点击延迟的来龙去脉 FT Labs CustomEvent More Responsive Tapping on iOS New Interaction Behaviors in iOS 10 Amaze UI JS 插件 FastClick 各主流浏览器内核介绍 FastClick 填坑及源码解析]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[写于入职丁香园一年之际]]></title>
    <url>%2F2017%2F02%2F28%2Fa-year-in-dxy%2F</url>
    <content type="text"><![CDATA[晚饭后坐在电脑前，莫名的想看一下日期，突然意识到：自己入职花厂一年了。轻轻地回忆一下，就能想起去年3月1日第一天入职的情形。 遇见与丁香园的故事，可以从2016年正月初七，在合肥下飞机后开机的那一刻说起。 当得知整个创业团队的技术产品相关人员继续放几个月的假后，在回住处的机场大巴上，有一段时间脑海中一片空白。多次尝试和创业团队核心人员沟通无果后，决定去寻找新的机会。当时自己的技术背景比较复杂：实习的时候做过网站、手游，写过几个月的PHP，用了一段时间 Node.js；加入创业团队后，和科大的两个朋友（做技术的泊洲和做产品的阿牧）共三个人扛起了公司官网、app、内部 CRM 系统、微信运营活动等所有技术产品相关工作。而当自己确定去寻找新的机会时，却发现自己并没有在哪个方向做到精通的地步。思考之后，选择了自己最擅长的前端方向作为切入点。 穿着马丁靴在杭州奔波到第四天下午，脚跟每走一步都会隐隐作痛。此时拿到了六家的 offer，走出某公司后，坐在路边思考是继续后续两天的面试，还是从现有 offer 中选择一家。杭州初春的阳光打在身上，整个人被照的暖暖的，同时也把整个人照的更加疲惫了。一番思索后，选择停留在如涵电商、In 和丁香园上。举棋不定之际，给泊洲兄打了电话。他听过目前的选择后，给出了建议：丁香园。在与泊洲兄共事的几个月中，对他的技术、眼界还是比较认可的。加上在丁香园电话面试、笔试、三轮面试过程中，以及和 HR 接触过程中，给我的感觉很不错，最终选择了丁香园。 收获大四开始，我进入了一家由一对海归夫妻创办的创业型游戏公司实习。毕业后加入到一支由留学生、科大学生组建的创业团队，准备在教育领域杀出一片天地。 第一家公司做技术的男 Boss 是从微软出来的，对他的印象始终定格在是一个技术很不错的人（公司用的服务器软件是他自己用 Erlang 写的），女 Boss 也有硅谷从业经历，所以整个公司技术的工作流在很多地方有微软的影子。在未融资之前，整个团队的氛围也比较nice。 第二家公司，泊洲在阿里实习过，阿牧出国学习过，加之技术产品相关的一共就我们三个人，所以技术选型和使用工具上就比较“开明”。在这个过程中，我接触上到了Git、Quip、Coding等更为好用的工具，以及Django、AngularJS、Ionic等软件开发框架。 这两家创业公司各有各的优势，并且分别在游戏领域和教育领域。14年加入第一家公司时，国内的手游行业正处于爆发增长时期。教育与互联网的结合，想象和发挥空间更是巨大。自己最初选择加入时，都是雄心勃勃，准备大干一场，而最终离开时，心中都是百感交集。 客观的说，当时是笼罩在创业失败的阴影下，带着一个做全“干”工程师的心和略微复杂的技术背景加入丁香园的前端团队的。 入职的第一天，是和小秋姐一起去的公司。入职培训后，就见到了对我进行电话面试和第一轮面试的王翀，以及看上去和蔼可亲的东星。安装开发工具、搭建开发环境、认识了一圈前端组的伙伴、发了入职介绍的邮件，就算是正式开始了在丁香园的日子。 入职后接触的第一条产品线是丁香调查。产品线的两个后台系统，第一行代码开始写时，我应该还在上初中。浏览官网代码时，也看到了岁月的痕迹。唯一年轻一些的调查问卷项目，总是会听到 bug 飞来飞去的声音。在这样的背景下，我和婧怡、小印姐、建科一起踏上了优化后台、完善官网功能、开发新版调查问卷的路。 点燃我2016年沸点的事情，便是开发新版调查问卷这件事情。如果要用两个字来概括这个项目的话，非“复杂”莫属。设计精美、交互流畅、功能强大，应该说的就是新版调查问卷了（羞涩ing）。技术实现上，完全数据驱动，高度灵活的配置项，友好的支持商业项目定制。至今我都没有找到一种很好的方式，可以向别人描述清楚，为什么一份小小的调查问卷，需要投入几个月的资源去开发。这样描述，或许能让人稍微理解一些：业界能说比新版调查问卷好看并且交互好的问卷，功能没有丁香调查问卷多，功能敢说比丁香调查问卷多的，应该是它在吹牛。 新版问卷开发期间，有一个小插曲：使用 React Native 参与了丁香医生 app 的开发，接触到了增量发布等一些有趣的事情。问卷稳定后，我接触到了第二条to B的产品线：Insight，负责了一个比较大的模块的开发。这样的一个经历，让我对to B的商业产品的开发，有了更深一层的认知。 人一旦忙起来了，时间过得就会特别快。转眼间红了樱桃，绿了芭蕉，到了北方秋天树叶变黄，进而飘落的季节。记忆中是某天快下班的时候，国内整个前端圈突然沸腾了一下：微信团队搞事情了—小程序开始内测。 由于有AngualrJS、React的项目经验，开发小程序这件事情就变得没有什么挑战。有一天在群里看到东星说丁香医生可能会做一个小程序，恰好那时刚刚把手上需求清掉了一波儿，便花了点时间把 丁香医生+ 的雏形搭了起来。（写到这里，需要跟正在读这篇文字的你说一下：如果你还没有使用过丁香医生+小程序，建议你尝试一下，尤其是你的朋友圈经常可以看到一些传说中的养生文章。）时至今日，小程序的热度正在慢慢退却，这或许正是小程序本该有的状态。 关于收获部分，写的文字有点多。总结一下，加入丁香园之后，个人技术和项目经验上有了很大的进步，对一个互联网公司中技术产品部门的认知更近了一步，体会到了不同部门的协作、沟通的重要性，更加懂得了合作的意义，对一个较大技术团队的运作有了更清楚的了解。 技术层面，前端技术栈中，在原有的网站、AngualrJS、Ionic，新增了React、React Native、Vue、微信小程序、Webpack的技能点。16年年底时，参加了几场技术会议，进一步拓宽了自己技术层面的视野。 项目经验上，增加了SPA、To B 商业项目、React Native项目、微信小程序的经验值。 另一笔宝贵的财富就是，收获了一群有爱的伙伴：前端组的伙伴、丁香调查产品线、Insight产品线、大众医学部、街舞小分队、书法小分队、划船不用桨小分队 and more. 回顾过去的一年，收获还是很大的。 最想说的话最想说的话，应该是感谢吧。 感谢当初耿娟姐、王翀、东星、范老师给我加入丁香园的机会，感谢遇到困惑时师傅王翀的尊尊教诲，感谢做项目期间晓涛给予的大量帮助，感谢这一年成长路上东星的指导。感谢在做新版调查问卷过程中辛苦付出的婧怡和小印姐，感谢每一位在我成长过程中给予帮助和指导的前辈、朋友们，感谢所有和我有交集并顺利合作的同事们。 一口气写了这么多感谢，不过是真心的感谢。 不足一年的时间，虽然成长了很多，但是自身的不足还是有的。首当其中的是技术的深度，其次是视野上的广度。在沟通和表达能力方面，也需要提高。 读书的时间也变少了，这一点不好。 技术上，绝大多数时间都耗在业务层面上，缺乏其他层面的沉淀。希望今年可以做一些有趣的尝试。 练了大概两本的硬笔书法，不过年后被搁浅了。在写字的过程中，有时候可以体会到《功夫熊猫》中的inner peace，这还是一种不错的体验的。 另一个痛点是：自从毕业后，体重随着个人的进步也在增加。去年 G20 之后，坚持锻炼了一个多月，瘦了十多斤。入冬后，锻炼少了体重又增加了。今年一定要解决这个痛点。 写在最后这个公众号是2015年8月22日注册的，赶到入职丁香园一年之际，才匆匆码出第一篇文章。行文流水间，默然抬首，时间已是3月2日凌晨。So，文章后半部分匆忙带过。 希望借此之际开始写文字后，自己可以在这里沉淀更多的有价值的内容。 从来没想过在游走了游戏行业、教育行业两个互联网创业公司后，自己会进入一家医疗健康领域的互联网公司，然而它却发生了。一年的时间，说长不长，说短不短。新的一年，继续努力。​“我时常盼望自己也能经历这样一场风云际会，不论成败，杀个痛快。但愿这一天早点到来”。—— 摘自公众号【二爷鉴书】的文章《启发者，马斯克》 写于2017年3月1日 ~ 2017年3月2日]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[详解Lodash中的debounce和throttle]]></title>
    <url>%2F2017%2F02%2F15%2Fdebounce-throttle%2F</url>
    <content type="text"><![CDATA[在前端开发中，有两个常用的高阶函数：debounce 与 throttle。它们经常用来防止函数被高频调用。本文详细说明了 Lodash 中 debounce 和 throttle 的使用方法。 debounce（去抖）bounce可以翻译为弹跳、跳跃。 我们可以对应几个场景来进一步理解 bounce： 有一根弹簧，一端固定好，另一端拉伸后松开，弹簧就会在一定时间内不停地 bounce。 在街舞的教学中，有的老师会和学生强调 “bounce” 的练习。可以粗略的理解为：身体跟着音乐要不停地律动。 在我们使用鼠标时，有时候会连续点击鼠标。 概括来说，bounce 可以广义理解为：在一定时间内连续做某件事。 了解了bounce，debounce 要做什么事情就变得非常清晰：阻止在一定时间内连续做某件事。 Lodash 中的 debounce 方法使我们可以将连续多次的函数调用归为一次调用。 函数原型及参数详解1234567891011121314151617/** * 创建一个会在 `wait` 毫秒后调用 `func` 的防抖动函数。 * 最后一次传入 `func` 参数会传给防抖动函数，随后调用的防抖动函数返回是最后一次 func 调用的结果。 * 防抖动函数提供 cancel 方法来取消延迟的函数调用 以及 flush 方法来立即执行函数调用。 * * 注意: 如果 leading 和 trailing 都设定为 true，则 func 允许 trailing 方式调用的条件为: 在 wait 期间多次调用。 * * @param &#123;Function&#125; func 要防抖动的函数 * @param &#123;number&#125; [wait=0] 需要延迟的毫秒数 * @param &#123;Object&#125; [options=&#123;&#125;] 选项对象 * @param &#123;boolean&#125; [options.leading=false] 指定调用在延迟开始前 * @param &#123;number&#125; [options.maxWait] 设置 `func` 允许被延迟的最大值 * @param &#123;boolean&#125; [options.trailing=true] 指定调用在延迟结束后 * @returns &#123;Function&#125; 返回一个具有防抖动功能的函数 */_.debounce(func, [wait=0], [options]) 示例12345678910111213141516// 避免窗口在变动时出现昂贵的计算开销jQuery(window).on('resize', debounce(calculateLayout, 150))// 当点击时 `sendMail` 随后就被调用jQuery(element).on('click', debounce(sendMail, 300, &#123; 'leading': true, 'trailing': false &#125;)) // 确保 `batchLog` 调用1次之后，1秒内会被触发const debounced = debounce(batchLog, 250, &#123; 'maxWait': 1000 &#125;)const source = new EventSource('/stream')jQuery(source).on('message', debounced)// 取消一个 trailing 的防抖动调用jQuery(window).on('popstate', debounced.cancel) throttle（节流阀）从字面意思上看可以理解为事件在一个管道中传输，加上这个节流阀以后，事件的流速就会减慢。 throttle 的实际作用也是如此：限制一个函数在一定时间内只能执行一次。 函数原型及参数详解12345678910111213141516/** * 创建一个在 wait 秒内最多执行 func 一次的节流函数。 * 最后一次传入 `func` 参数会传给节流函数，随后调用的节流函数返回是最后一次 func 调用的结果。 * 节流函数提供 cancel 方法来取消延迟的函数调用 以及 flush 方法来立即执行函数调用。 * * 注意: 如果 leading 和 trailing 都设定为 true，则 func 允许 trailing 方式调用的条件为: 在 wait 期间多次调用。 * * @param &#123;Function&#125; func 要节流的函数 * @param &#123;number&#125; [wait=0] 需要节流的毫秒 * @param &#123;Object&#125; [options=&#123;&#125;] 选项对象 * @param &#123;boolean&#125; [options.leading=true] 指定调用在节流开始前 * @param &#123;boolean&#125; [options.trailing=true] 指定调用在节流结束后 * @returns &#123;Function&#125; 返回一个具有防抖动功能的函数 */_.throttle(func, [wait=0], [options]) 示例123456789// 避免在滚动时过分的更新定位jQuery(window).on('scroll', throttle(updatePosition, 100))// 点击后就调用 `renewToken`，但5分钟内超过1次。const throttled = throttle(renewToken, 300000, &#123; 'trailing': false &#125;)jQuery(element).on('click', throttled);// 取消一个 trailing 的节流调用jQuery(window).on('popstate', throttled.cancel) debounce 和 throttle 区别在 Lodash 中，throttle 方法是基于 debounce 实现的。 主要区别是 throttle 保证方法每 wait 秒内有规律的执行。 一个相当常见的例子，用户在你无限滚动的页面上向下拖动，你需要判断现在距离页面底部多少。如果用户快接近底部时，我们应该发送请求来加载更多内容到页面。这种情况下， debounce 是没有用的，因为它只会在用户停止滚动时触发，但我们需要用户快到达底部时去请求。通过 throttle 我们可以不间断的监测距离底部多远。 参考 debounce throttle Debounce and Throttle: a visual explanation]]></content>
      <tags>
        <tag>lodash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈软件开发的技术选型]]></title>
    <url>%2F2017%2F01%2F16%2Ftechnical-selection-of-software-development%2F</url>
    <content type="text"><![CDATA[2016 年刚入冬的时候，决定利用工作之余和两个朋友一起尝试做一个互联网产品。朋友 A 是写 Java 出身，有 Java 服务端开发和安卓开发经验。朋友 B 是国内一家互联网公司的产品。我的技术背景略复杂。当年拿着应聘 Java 实习生的简历找到了一份前端开发的工作，进入公司之后却用 Cocos2d-js 开发起了游戏。游戏上线后，持续写了 3 个月左右的 CSS。突然有一天，Boss 说想要一个游戏社区，要尽快上线，于是撸起袖子玩起了 PHP 和 MySQL（基于 WordPress 二次开发）。社区第一版上线后，我便请假回学校准备毕业答辩。答辩结束回到公司后，Boss 说要把社区和现有官网整合到一起。于是便开启了一段让我成长很多的旅程（旅途前半程搭了 jQuery、Node、sqlite3 的车，后半程上再次上了 PHP 和 MySQL 的船）。一个偶然的机会了解到一个做家教 O2O 的创业团队，便加入其中玩起了 Angualr 1 和 Ionic，还顺带折腾了一下 Django。再后来，就入职了花厂，操起了前端这把刀，专心的舞了起来。 最初决定后台大体的技术方案时，有如下 5 种方案： Java + MySQL PHP + MySQL Python（Django） + MySQL Node.js + MySQL Node.js + Mongodb 当时我们讨论了几次，去读了一些关于后台技术选型的文章、图书和网上资料，再加上个人的经验决定选择 PHP + MySQL 作为后台的技术方案。不选择 Java 的原因主要是认为 Java 开发效率较低(想想大学时接触的 J2EE 和 SSH，脑中浮现的总是“重”的印象)，加上我只记得一些 Java 的基本语法和概念了，不能为 A 分担太多工作量。我和 A 都不能确保使用 Django 可以保证项目进行的顺利，所以放弃了 Python 的方案。A 对 Node.js 不熟悉，加上业界很少只用 Node.js 承载后台业务的，所以和 Node.js 也 say goodbye 了。PHP 嘛，以上手简单、开发效率高著称，加上 PHP 7 性能有了很大的提升，左看右看上看下看就属它合适了。 选择了后台使用的语言和数据库后，就到了选择后台框架的阶段。一番翻云覆雨过后，选定了 PHP 界的一颗新星 — Laravel。 事情进行到这里，一切都是那么的顺畅。似乎是选择了一个别人口中简单易上手的东西，自己便可以轻松搞定一切的样子。 从我开始搭建开发环境的那一刻起，我就意识到事情没那么简单。熟悉的随便装一个 XAMPP，然后把 PHP 代码丢在服务器上的光阴一去不复返。跟着官网的教程，逐步把项目跑起来，写好说明文档后，代码推到 Coding，便把项目地址和说明文档交给了 A。]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[给使用 Git 做版本控制的项目添加 Wiki]]></title>
    <url>%2F2017%2F01%2F06%2Fgit-wiki%2F</url>
    <content type="text"><![CDATA[安装使用安装 RubyMac OS X： $ brew install ruby 可使用如下命令检测是否安装成功（能够正常显示版本号则说明安装成功）： $ ruby -v 安装 Gollum$ sudo gem install gollum 可使用如下命令检测是否安装成功（能够正常显示版本号则说明安装成功）： $ gollum --v 克隆 Wiki 项目从 GitHub 或者 GitLab 上克隆项目 ProjectA 的 Wiki 项目到本地 ProjectA 的目录： $ cd ProjectA $ git clone git@gitlab.dxy.net:f2e/ProjectA.wiki.git $ cd ProjectA.wiki 运行 Gollum 并且在本地编辑项目的 Wiki$ gollum 访问http://127.0.0.1:4567/ 即可开始在浏览器中编写Wiki。 参考gollum:给wiki插上git的翅膀]]></content>
      <tags>
        <tag>Wiki</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vagrant]]></title>
    <url>%2F2016%2F12%2F29%2Fvagrant%2F</url>
    <content type="text"></content>
      <tags>
        <tag>Vagrant</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel 教程（一）--- 开发环境搭建]]></title>
    <url>%2F2016%2F12%2F29%2Flaravel-start%2F</url>
    <content type="text"><![CDATA[储备知识 &amp; 准备工作Mac 修改环境变量查看当前环境变量 echo $PATH 如果默认shell是bash，那么shell启动时会触发.bashrc；如果默认shell是zsh，那么shell启动时会触发.zshrc。 设置PATH的语法为：export PATH=&quot;$PATH:&lt;PATH 1&gt;:&lt;PATH 2&gt;:...:&lt;PATH N&gt;&quot; 安装最新稳定版本的 PHPMac参考 https://php-osx.liip.ch/#install $ curl -s https://php-osx.liip.ch/install.sh | bash -s 7.1 然后修改环境变量： $ ~ vi .zshrc 添加： export PATH=/usr/local/php5/bin:$PATH 在命令行执行： $ ~ source .zshrc Windows在官网下载对应版本，然后解压到本次磁盘某位置(比如：D:\php-7.1.0)即可。 在下载页面下载时，会需要选择 Thread Safe 和 Non Thread Safe。主要区别在于在执行 PHP 时是否需要进行线程安全检查。如果搭配 Apache 使用 PHP 的话，建议选择 Thread Safe 版本。 或者 直接使用 XAMPP。 安装好后，配置一下 PHP 的环境变量。 查看 PHP 版本：$ php -v 安装 ComposerComposer 是 PHP 用来管理依赖（dependency）关系的工具。你可以在自己的项目中声明所依赖的外部工具库（libraries），Composer 会帮你安装这些依赖的库文件。 官网 中文网 如果进行 PHP 项目的开发，建议使用 Composer。 国内使用，建议系统全局更换掉默认镜像源： composer config -g repo.packagist composer https://packagist.phpcomposer.com 使用 Composer 安装 Laravel先安装 Laravel 项目生成器 composer global require &quot;laravel/installer&quot; 确保 ~/.composer/vendor/bin 在系统路径中，否则不能在任意路径调用 laravel 命令。 可使用如下命令检测是否安装成功（能够正常显示版本号则说明安装成功）： $ laravel -v 安装完成后，通过简单的 laravel new 命令即可在当前目录下创建一个新的 Laravel 应用。例如，laravel new blog 将会创建一个名为 blog 的新应用，且包含所有 Laravel 依赖。 开发环境搭建简介官方为我们提供了一整套本地开发环境 —— Laravel Homestead。 Laravel Homestead 是一个打包好各种 Laravel 开发所需要的软件及工具的 Vagrant 盒子（Vagrant 提供了一个便捷的方式来管理和设置虚拟机），该盒子为我们提供了优秀的开发环境，有了它，我们不再需要在本地环境安装 PHP、HHVM、Web服务器以及其它工具软件，我们也完全不用再担心误操作搞乱操作系统 ——因为 Vagrant 盒子是一次性的，如果出现错误，可以在数分钟内销毁并重新创建该 Vagrant 盒子！ Homestead可以运行在 Windows、Mac 以及 Linux 系统上，其中已经安装好了Nginx、PHP7.0、MySQL、Postgres、Redis、Memcached、Node以及很多其它开发 Laravel 应用所需要的东西。 注：如果你使用的是Windows，需要开启系统的硬件虚拟化（VT-x），这通常可以通过BIOS来开启。如果你是在UEFI系统上使用 Hyper-V，则需要关闭 Hyper-V以便可以访问VT-x。 安装安装虚拟机（Virtual Box 或者 VMWare）Virtual Box 免费 VMWare 收费 安装 Vagrant在官网下载对应操作系统的Vagrant安装包进行安装即可。 安装完成后，在命令行输入： $ vagrant --version 如果可以看到版本信息，即说明安装成功。 安装 Homestead Vagrant 盒子VirtualBox/VMWare 和 Vagrant 安装好了之后，在终端中使用如下命令将 laravel/homesterad 添加到 Vagrant 中。下载该盒子将会花费一些时间，时间长短主要取决于你的网络连接速度： vagrant box add laravel/homestead 如果上述命令执行失败，需要确认Vagrant是否是最新版本。 注：国内由于网络原因，可能会导致上述下载失败。 此时可以找到执行上述命令后命令行输出的下载地址，然后使用迅雷等软件将box下载下来。 下载好后，cd 到下载文件所在目录，执行vagrant box add laravel/homestead virtualbox.box， 成功添加box后会提示”Successfully added box ‘laravel/homestead’ (v0) for ‘virtualbox’!“。 在命令行输入vagrant box list，会显示已经安装好的box的信息。 如果采用该离线安装模式，需要修改/Users/lizhiyao/Homestead/scripts/homestead.rb， 将其中version改为&lt;=。 通过 GitHub 安装 Homestead将仓库克隆到用户目录下的 Homestead 目录，这样 Homestead 盒子就可以作为所有其他 Laravel 项目的主机 $ cd ~ $ git clone https://github.com/laravel/homestead.git Homestead 克隆完成后，在 Homestead 目录下，Mac用户运行 bash init.sh 命令来创建 Homestead.yaml 配置文件，Windows 用户执行 init.bat 即可。 Homestead.yaml 配置文件文件位于 ~/.homestead 目录。 配置$ vi ~/.homestead/Homestead.yaml 配置 Providerprovider: virtualbox 配置共享文件夹Homestead.yaml 文件中的 folders 属性列出了所有主机和 Homestead 虚拟机共享的文件夹。一旦这些目录中的文件有了修改，将会在本地和 Homestead 虚拟机之间保持同步。如果有需要的话，你可以配置多个共享文件夹（一般一个就够了）： folders: - map: /Users/lizhiyao/Documents/projects/yifood to: /home/vagrant/Code 配置 Nginx 站点sites: - map: yifood.dev to: /home/vagrant/Code/public Hosts文件把 Nginx 站点配置中的域名添加到本地机器上的 hosts 文件中 该文件会将对本地域名的请求重定向到 Homestead 虚拟机，在 Mac 或 Linux上，该文件位于 /etc/hosts，在 Windows 上，位于C:\Windows\System32\drivers\etc\hosts 192.168.10.10 yifood.dev 确保 IP 地址和你的 Homestead.yaml 文件中列出的一致，一旦你将域名放置到 hosts 文件，就可以在浏览器中通过该域名访问站点了。 Windows 用户在修改 hosts 时，可能会遇到没有权限问题。此时将 hosts 文件拖到桌面修改后再拖回原文件夹即可。 启动 Vagrant Box配置好 Homestead.yaml 文件后，进入Homestead 目录 /Users/lizhiyao/Homestead 在 Homestead 目录下运行 vagrant up 命令，Vagrant 将会启动虚拟机并自动配置共享文件夹以及 Nginx 站点。 销毁 vagrant destroy –force ssh vagrant ssh 预览可以访问http://192.168.10.10/ 或者http://127.0.0.1:8000/ 查看运行起来的项目。 由于我们配置了hosts文件，所以还可以通过我们自定义的域名yifood.dev来访问。 开发由于设置了共享目录，所以可以在虚拟机上进行开发，也可以在本机上进行开发。 参考Laravel 5.3 中文文档]]></content>
      <tags>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[yeoman]]></title>
    <url>%2F2016%2F12%2F28%2Fyeoman%2F</url>
    <content type="text"><![CDATA[Yeoman 是什么？构建 Web app 脚手架的工具。 npm install -g yo 首先，为你即将写的 generator 创建一个文件夹。这个文件夹必须命名为 generator-name (这里的 name 就是你 generator 的名字)。这是很重要的，作为 Yeoman 的依赖文件系统来查找可用的 generators。 touch generator-namecd generator-namenpm initnpm install –save yeoman-generatormkdir generators 安装您的项目依赖项和链接一个全局模块到本地文件npm link]]></content>
      <tags>
        <tag>yeoman</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[https]]></title>
    <url>%2F2016%2F12%2F19%2Fhttps%2F</url>
    <content type="text"><![CDATA[人这一生要经历很多事情，越过众多山丘，其中有些事情是冥冥之中注定了的，逃脱不得。比如：如果你是一名前端工程师，HTTPS 的掌握就是你成长路上必须征服的一座山。 什么是 HTTPS ？HTTPS 是最常见的 HTTP 安全版本。它是由网景公司首创的，所有主要的浏览器和服务器都支持此协议。HTTPS 将 HTTP 协议与一组强大的对称、非对称和基于证书的加密技术结合在一起，使得 HTTPS 不仅很安全，而且很灵活，很容易在处于无序状态的、分散的全球互联网上进行管理。 HTTPS 方案的 URL 以 https:// 开头，据此就可以分辨某个 Web 页面是通过 HTTPS还是 HTTP 访问的（有些浏览器还会显示一些标志性的安全提示）。 使用 HTTPS 时，所有的 HTTP 请求和响应数据在发送到网络之前，都要进行加密。HTTPS 在 HTTP 下面提供了一个传输级的密码安全层—可以使用SSL(Secure Sockets Layer，安全套接层协议），也可以使用其后继者TLS（Transport Layer Security，传输层安全协议）。SSL 和 TLS 是非常类似的。 HTTPS 是位于安全层之上的 HTTP，这个安全层位于 TCP 之上。如下图所示： HTTP HTTPS 应用层 HTTP HTTP 安全层 无 SSL or TLS 传输层 TCP TCP 网络层 IP IP 数据链路层 网络接口 网络接口 大部分困难的编码以及解码工作都是在 SSL 库中完成的，所以 Web 客户端和服务器在使用安全 HTTP 时无需过多的修改器协议处理逻辑。在大多数情况下，只需要用 SSL 的输入/输出调用取代 TCP 的调用，再增加其他几个调用来配置和管理安全信息就行了。 为什么需要 HTTPS ？简而言之，使用 HTTPS 就是为了安全，Web 需要一种安全的 HTTP 形式。 详细点儿说呢？可以说的理由简直不要太多：人们会利用 Web 事务来处理一些很重要的事情。如果没有强有力的安全保证，人们就无法安心地进行网络购物或者使用银行业务。如果无法严格限制访问权限，公司就不能将重要的文档放在 Web 服务器上······ 数字加密既然涉及到安全，就会涉及到加密和解密。在继续深入了解 HTTPS 之前，需要知道一些加密编码的知识。 密码学密码学是对报文进行编/解码的机制与技巧。 应用密码学知识可以做到： 加密报文，防止好事者读取报文 防止某些人对报文进行篡改 证明某条报文或某个事务确实出自某处 密码密码学基于一种名为密码（cipher）的秘密代码。密码是一套编码方案—一种特殊的报文编码方式和一种编码后使用的相应解码方式的结合体。 加密之前的原始报文通常被称为明文（plaintext 或 cleartext），使用了密码之后的编码报文通常被称作密文（ciphertext）。 明文 —&gt; 编码器 —&gt; 密文 —&gt; 解码器 —&gt; 明文 密码机最初，人们需要自己进行编码和解码，所以起初密码是相当简单的算法。因为密码很简单，所以人们通过纸笔和密码书就可以进行编解码了，但聪明人可以相当容易地破解这些密码。 随着技术的进步，人们开始制造一些机器，这些机器可以用复杂得多的密码来快速、精准地对报文进行编解码。 秘钥编码算法和编码机都可能会落入敌人手中，所以大部分机器上都有一些号盘，可以将其设置为大量不同的值以改变密码的工作方式。即使机器被盗，没有正确的号盘设置（密钥值），解码器也无法工作。 这些密码参数被称为秘钥（key）。要在密码机中输入正确的密钥，解密过程才能正确进行。密码秘钥会让一个密码机看起来好像是多个虚拟密码机一样，每个密码机有不同的密钥值，因此其行为都会有所不同。 数字密钥随着数字计算的出现，出现了数字密钥。与金属钥匙或机械设备中的号盘设置相比，数字密钥只是一些数字。这些数字密钥值是编/解码算法的输入。编码算法就是一些函数，这些函数会读取一块数据，并根据算法和密钥值对其进行编/解码。 假定报文为 P，编码函数为 E， 一个编码密钥为 e，经过编码的密文为 C，则上述关系可以用表达式描述为： C = E(P, e) 对称密钥（symmetric-key）加密技术在编码时和解码时使用相同的密钥的技术，被称为对称密钥加密技术。 在对称密钥加密技术中，发送端和接收端要共享相同的密钥才能进行通信。发送端用共享的密钥来加密报文，并将得到的密文发送给接收端。接收端收到密文，并对其应用解密函数和相同的共享密钥，恢复出原始的明文。 流行的对称密钥加密算法包括：DES、Triple-DES、RC2 和 RC4。 在很多情况下，编/解码算法都是众所周知的，因此密钥就是唯一保密的东西了。 枚举攻击好的加密算法会迫使攻击者试遍每一个可能的密钥，才能破解代码。 暴力的去尝试所有的密钥值的方式被称为枚举攻击（enumeration attack）。 缺点对称密钥加密技术的缺点之一就是发送者和接受者在互相对话之前，一定要有一个共享的保密密钥。 如果有 N 个节点，每个节点都要和其他所有 N-1 个节点进行安全对话，总共大概会有 N² 个保密密钥，这将是一个管理噩梦。 公开密钥加密技术公开密钥加密技术没有为每对主机使用单独的加密/解密密钥，而是使用了两个非对称密钥：一个用来对主机报文编码，另一个用来对主机报文解码。编码密钥是众所周知的（这也是公开密钥加密的由来），但只有主机才知道私有的解密密钥。这样，每个人都能找到某个特定主机的公开密钥，密钥的建立变得更加简单。但解码密钥是保密的，因此只有接收端才能对发送给它的报文进行解码。 RSARSA 算法是一个流行的公开密钥加密系统，它是在 MIT 发明的，后来由 RSA 数据安全公司将其商业化。即使有了公钥、任意一段明文、用公钥对明文编码之后得到的相关密文、RSA 算法自身，甚至 RSA 实现的源代码，破解难度就很大。这个困难被认为是所有计算机科学中最难的问题之一。 混合加密系统和会话密钥公开密钥技术的一个问题是加密算法的计算可能会很慢。实际上它混合使用了对称和非对称策略。 比较常见的做法是：在两个节点间通过便捷的公开密钥加密技术建立起安全通信，然后再用那条安全的通道产生并发送临时的随机对称密钥，通过更快的对称加密技术对其余的数据进行加密。 存在问题接收方不能确认收到的公开密钥是预期的发送方发行的公开密钥，也许在公开密钥传输过程中就已经被替换掉了。 使用数字证书可以解决这个问题。数字签名（digital signing）除了加/解密报文之外，还可以用加密系统对报文进行签名（sign），以说明是谁编写的报文，同时证明报文未被篡改过。这种技术被称为数字签名。 数字签名是附加在报文上的特殊加密校验码，通常是用分对称公开密钥产生的。 节点 A 给节点 B 发送一条报文，进行签名的过程通常如下： 节点 A 将 边长报文 提取为 定长摘要。 节点 A 对摘要应用一个“签名”函数，这个函数会将节点 A 的私有密钥作为参数。 因为只有节点 A 才知道私有密钥，所以正确的签名会说明签名者就是其所有者。 一旦计算出签名，节点 A 就将其附加在报文的末尾，并将报文和签名都发送给 B。 在接收端，如果节点 B 需要确定报文确实是节点 A 写的，而且没有被篡改过，节点 B 可以对签名进行检查。节点 B 接收经私有密钥扰码的签名，并应用了 使用公开密钥的 反函数。如果拆包后的摘要与节点 B 自己的摘要版本不匹配，要么就是报文在传输过程被篡改了，要么就是发送端没有节点 A 的私有密钥（也就是说发送端不是节点 A） 数字证书数字证书（certs）中包含了由某个受信任组织担保的用户或公司的相关信息。 证书的主要内容基本的数字证书通常包含一些纸质 ID 中常见的内容，比如： 对象的名称（人、服务器、组织等） 过期时间 证书发布者 来自证书发布者的数字签名 此外，数字证书通常还包括对象的公开密钥，以及对象和所用签名算法的描述性信息。 X.509 v3证书数字证书没有单一的全球标准，但是目前使用的大多数证书都以一种标准格式（X.509 v3）来存储信息。 X.509 证书字段表 字段 描述 版本 这个证书的 X.509 证书版本号。现在通常都是版本3 序列号 证书颁发机构（CA）生成的唯一整数。CA生成的每个证书都要有一个唯一的序列号 签名算法ID 签名所使用的加密算法。例如：“用 RSA 加密的 MD2 摘要” 证书颁发者 发布并签署这个证书的组织名称，以 X.500 格式表示 有效期 此证书合适有效，由一个初始日期和一个结束日期来表示 对象名称 证书中描述的实体，比如一个人活一个组织。对象名称是以 X.500 格式表示的 对象的公开密钥信息 证书对象的公开密钥，公开密钥使用的算法，以及所有附加参数 发布者唯一的 ID (可选) 证书发布者唯一标识符 对象唯一的 ID (可选) 证书对象唯一标识符 基于 X.509 证书的签名有好几种，包括：Web 服务器证书、客户端电子邮件证书、软件代码签名证书和证书颁发机构证书。 用证书对服务器进行认证通过 HTTPS 建立了一个安全 Web 事务之后，现代的浏览器都会自动获取所连接服务器的数字证书。如果服务器没有证书，安全链接就会失败。 服务器证书中包含很多字段，其中包括： Web 站点的名称和主机名 Web 站点的公开密钥 签名颁发机构的名称 来自签名颁发机构的签名 HTTP 和 HTTPS 区别和优劣 参考 《HTTP 权威指南》 传输层安全协议 数字签名是什么？]]></content>
      <tags>
        <tag>HTTPS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flex 布局]]></title>
    <url>%2F2016%2F12%2F08%2Fflex%2F</url>
    <content type="text"><![CDATA[前言页面布局，是前端开发中的一个重点。 传统的 PC 端布局方式有： 基于 CSS 盒模型，依赖 CSS 的 display、position 和 float 属性的固定布局 基于百分比的流体布局 很明显，以上两种布局方式不太适合移动端的页面布局。 最近这几年，基于 CSS 媒体查询 和 流体布局 的响应式布局使得移动端的页面布局变得生机勃勃。 不过，有的时候，似乎固定布局、流体布局、响应式布局都不太合适某个需求。这里所说的不合适，可能是固定布局这种明显的不合适，也可能是流体布局、响应式布局这种可以耗费一定的时间可以实现需求但是实现成本略高的不合适。 既然存在问题，世界这么大，肯定就会有聪明的人提出解决方案，所以前端开发领域有了一种新的布局方案：Flex 布局。 顺便提一句，今年做的丁香调查问卷的项目，是基于 rem 的固定布局和 Flex 布局混合使用的。各种布局方案灵活混合使用，可以更轻松的实现产品需求，提高开发效率。这或许是“知行合一”思想的一个实践。 Flexible 这个词用得很好，可以理解为：给盒状模型提供最大的灵活性。 核心思想：基于元素个数不同，自动填充容器。 基础知识 Flex容器（flex container）：采用Flex布局的元素，称为Flex容器，简称”容器” Flex项目（flex item）：Flex容器的所有子元素自动成为容器成员，称为Flex项目，简称”项目” 主轴（main axis）：Flex容器默认水平方向有一根轴，称为主轴 交叉轴（cross axis）：Flex容器默认垂直方向有一根轴，称为交叉轴 main start：主轴开始的位置与Flex容器边框的交叉点 main end：主轴结束的位置与Flex容器边框的交叉点 cross start：交叉轴开始的位置与Flex容器边框的交叉点 cross end：交叉轴结束的位置与Flex容器边框的交叉点 默认情况下，项目沿主轴排列且项目都排在一条轴线上 main size：单个项目占据的主轴空间 cross size：单个项目占据的交叉轴空间 Flex容器的属性Flex容器共有6个属性： flex-direction flex-wrap flex-flow justify-content align-items align-content flex-direction决定主轴的方向（即项目的排列方向）。它可能有4个值： row（默认值）：主轴为水平方向，起点在左端 row-reverse：主轴为水平方向，起点在右端 column：主轴为垂直方向，起点在上沿 column-reverse：主轴为垂直方向，起点在下沿 flex-wrap定义如果一条轴线排不下，如何换行。它可能取三个值： nowrap（默认）：不换行 wrap：换行，第一行在上方 wrap-reverse：换行，第一行在下方 flex-flowflex-flow 属性是 flex-direction 属性和 flex-wrap 属性的简写形式，默认值为：row nowrap justify-content定义了项目在主轴上的对齐方式。它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右： flex-start（默认值）：左对齐 flex-end：右对齐 center： 居中 space-between：两端对齐，项目之间的间隔都相等。 space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 align-items定义项目在交叉轴上如何对齐。它可能取5个值，具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下： flex-start：交叉轴的起点对齐。 flex-end：交叉轴的终点对齐。 center：交叉轴的中点对齐。 baseline: 项目的第一行文字的基线对齐。 stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 align-contentalign-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。该属性可能取6个值: flex-start：与交叉轴的起点对齐。 flex-end：与交叉轴的终点对齐。 center：与交叉轴的中点对齐。 space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。 space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 stretch（默认值）：轴线占满整个交叉轴。 Flex项目的属性Flex容器共有6个属性： order flex-grow flex-shrink flex-basis flex align-self order定义项目的排列顺序。数值越小，排列越靠前，默认为0。 flex-grow定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。 如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 flex-shrink定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。 如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。 flex-basisflex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。 flexflex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。 align-selfalign-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 该属性可能取6个值，除了auto，其他都与align-items属性完全一致。 示例1234.box &#123; display: -webkit-flex; display: flex;&#125; 等比划分 和 混合划分12345&lt;div class="container"&gt; &lt;div id="box-0"&gt;&lt;/div&gt; &lt;div id="box-1"&gt;&lt;/div&gt; &lt;div id="box-2"&gt;&lt;/div&gt;&lt;/div&gt; 等比划分12345678910111213141516.container &#123; display: -webkit-flex; display: flex;&#125;#box-0 &#123; flex: 1&#125;#box-1 &#123; flex: 2&#125;#box-2 &#123; flex: 1&#125; 混合划分12345678910111213141516.container &#123; display: -webkit-flex; display: flex;&#125;#box-0 &#123; width: 100px;&#125;#box-1 &#123; flex: 2&#125;#box-2 &#123; flex: 1&#125; 居中123456.parent &#123; display: -webkit-flex; display: flex; justify-content: center; align-items: center;&#125; 参考Flex 布局教程：语法篇Flex 布局教程：实例篇]]></content>
      <tags>
        <tag>Flex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leancloud log]]></title>
    <url>%2F2016%2F12%2F06%2Fleancloud-log%2F</url>
    <content type="text"><![CDATA[Web 应用开发上线后，难免会想去记录一下用户使用该产品时的一些信息。 之前使用过的有 Google Analytics、百度统计 以及丁香园自己的打点系统。 在开发丁香调查问卷时，由于访问调查问卷的设备覆盖面特别广，问卷刚开始上线时，会有个别用户反馈一些使用时出现的问题。 难点在于：有的时候，我们使用用户反馈的相同设备，做用户描述的相同操作，也不能重现问题。不能重现问题，前端和后台就很难去进行修复。 遂产生了记录用户行为的想法。 在实施该想法的过程中，发现文章开始提到的几个方案不是很合适：记录信息不够灵活，需要向其他部门负责人申请某些使用权限… 经过和相关人员沟通，决定暂时使用 leancloud 作为行为信息存储。 还是直接上代码吧。 具体实现先安装官方SDK npm install leancloud-storage --save 核心代码如下： 12345678910111213141516171819202122232425import AV from 'leancloud-storage';class Logger &#123; constructor(sid) &#123; // 应用 ID，用来识别应用 const APP_ID = ''; // 应用 Key，用来校验权限（Web 端可以配置安全域名来保护数据安全） const APP_KEY = ''; // 初始化 AV.init(&#123; appId: APP_ID, appKey: APP_KEY &#125;); this.dxySurvey = new (AV.Object.extend(sid)); &#125; save(infoObj) &#123; this.dxySurvey.save(infoObj); &#125;&#125;export default Logger; 注意 传给 Logger 的 sid 在 leancloud 中会作为一个类似于数据库名的使用，所以应该考虑好 sid 的命名。比如： S_12345、S_234234 必须设置 leancloud 应用的安全域名 参考LeanCloud Quick Start]]></content>
      <tags>
        <tag>log</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Photoshop 学习笔记]]></title>
    <url>%2F2016%2F12%2F04%2Fphotoshop%2F</url>
    <content type="text"><![CDATA[浑然天成的选区所有 ps 作品的创作都是从制作选区开始的。 创建精确的选区是让 Photoshop 作品取得成功的关键。]]></content>
      <tags>
        <tag>Photoshop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[客户端识别与 cookie 机制]]></title>
    <url>%2F2016%2F11%2F28%2Fserver-authentication%2F</url>
    <content type="text"><![CDATA[前言HTTP 最初是一个匿名、无状态的请求/响应协议。服务器处理来自客户端的请求，然后向客户端会送一条响应。Web 服务器几乎没有什么信息可以用来判定是哪个用户发送的请求，也无法记录来访用户的请求序列。 而现在越来越多的情况，我们的 Web 站点希望能够提供个性化的接触，希望对连接另一端的用户有更多的了解，并且能在用户浏览页面时对其最终。 本文对 HTTP 识别用户的几种方式进行了总结。需要知道的是，每种技术都有优劣。 常见的方式有： HTTP 头部。根据承载用户身份信息的 HTTP 头部信息进行判断 客户端 IP 地址跟踪。通过用户的 IP 地址对其进行识别 胖 URL。一种在 URL 中嵌入识别信息的技术 cookie。一种功能强大且高效的持久身份识别技术 用户登录。用认证的方式来识别用户 HTTP 头部七种最常见的用来承载用户相关信息的 HTTP 请求头部如下： From 用户的 E-mail 地址 User-Agent 用户的浏览器软件 Referer 用户是从哪个页面上依照链接跳转过来的 Authorization 用户名和密码 ClientIP（扩展） 用户的 IP 地址 X-Forwarded-For（扩展） 用户的 IP 地址 Cookie（扩展） 服务器产生的 ID 标签 这里先说明前三个： FromFrom 头部包含了用户的 E-mail 地址。 每个用户都有不同的 E-mail 地址，所以咋理想情况下，可以将这个地址作为可行的源端来识别用户。但由于担心那些不道德的服务器会搜集这些 E-mail 地址，用于垃圾邮件的散发，所以很少有浏览器会发送 From 头部。 实际上，From 头部是由自动化的机器人或蜘蛛发送的，这样在出现问题时，网管还有个地方可以发送愤怒的邮件。 User-AgentUser-Agent 头部可以将用户所用浏览器的相关信息告知服务器，包括程序的名称和版本，通常还包括操作系统的相关信息。 要实现定制内容与特定的浏览器及其属性间有良好互操作时，这个头部是很有用的，但它并没有为识别特定的用户提供太多有意义的帮助。 RefererReferer 头部提供了用户来源页面的 URL。 Referer 头部自身并不能完全标识用户，但它却可以说明用户之前访问过哪个页面。 通过它可以更好的理解用户的浏览行为，以及用户的兴趣所在 结论综上，From、User-Agent、Referer都不足以实现可靠的识别。 客户端 IP 地址还没开始往下看，或许就知道了这个方案的可行性了。结论是：最好不要使用这种方案。无法用 IP 地址确定目标的地方太多了。 少数站点甚至将客户端 IP 地址作为一种安全特性使用，它们只向来自特定 IP 地址的用户提供文档。在内部网络中或许可以这么做，但是在因特网上就不行了，主要是因为因特网上 IP 地址太容易伪造了。路径上如果有拦截代理，也会破坏此方案。 胖 URL （fat URL）有些 Web 站点会为每个用户生成特定的 URL 来追踪用户的身份。通常，会对真正的 URL 进行扩展，在 URL 路径开始或结束的地方添加一些状态信息。用户浏览站点时，Web 服务器会动态生成一些超链接，继续维护 URL 中的状态信息。 改动后包含了用户在状态信息的 URL 被称为胖 URL。 可以通过胖 URL 将 Web 服务器上若干个独立的事务捆绑成一个“会话”或“访问”。用户首次访问这个 Web站点时，会生成一个唯一的ID，用服务器可以识别的方式将这个 ID 添加到 URL 中去，然后服务器就会将客户端重新导向这个胖 URL。不论什么时候，只要服务器收到了对胖 URL 的请求，就可以去查找与那个用户ID 相关的所有增量状态（购物车、简介等），然后重写所有的输出超链，使其成为胖 URL，用以维护用户的 ID。 该方案存在几个严重的问题： 丑陋的 URL 无法共享 URL 破坏缓存 额外的服务器负荷 逃逸口（用户很容易跳出） 在会话间是非持久的 cookiecookie 是目前识别用户，实现持久会话的最好方式。 cookie 非常重要，而且它们定义了一些新的 HTTP 头部。cookie 的存在也影响了缓存，大多数缓存和浏览器都不允许对任何 cookie 的内容进行缓存。 cookie 的类型可以笼统的将 cookie 分为两类：会话 cookie 和持久 cookie。 会话 cookie 是一种临时 cookie，它记录了用户访问站点时的设置和偏好。用户退出浏览器时，会话 cookie 就被删除了。 持久 cookie 的生存时间更长一些，它们存储在硬盘上，浏览器退出、计算机重启时它们依然存在。通常用持久 cookie 维护某个用户会周期性访问的站点的配置文件或登录名。 会话 cookie 和 持久 cookie 之间唯一的区别就是它们的过期时间。如果设置了 Discard 参数，或者没有设置 Expires 或 Max-Age 参数来说明扩展的过期时间，这个 cookie 就是一个会话 cookie。 cookie 是如何工作的cookie 就像服务器给用户贴的“嗨，我叫XXX”的贴纸一样。用户访问一个 Web 站点时，这个Web 站点就可以读取服务器贴在用户身上的所有贴纸。 用户首次访问 Web 站点时，Web 服务器对用户一无所知。Web 服务器希望这个用户会再次回来，所以想给这个用户“拍上”一个独有的 cookie，这样以后他就可以识别出这个用户了。cookie 中包含了一个由 名字=值（name=value） 这样的信息构成的任意列表，并通过 Set-Cookie 或 Set-Cookie2HTTP 响应头部将其贴到用户身上去。 cookie 中可以包含任意信息，但它们通常都只包含一个服务器为了进行跟踪而产生的独特的识别码。 浏览器会记住从服务器返回的 Set-Cookie 或 Set-Cookie2 头部中的 cookie 内容，并将 cookie集存储在浏览器的 cookie 数据库中。将来用户访问同一个站点时，浏览器会挑中该站点服务器贴到用户身上的那些 cookie，并在一个 cookie 请求头部中将其给服务器传过去。 cookie罐：客户端的状态cookie 的基本思想就是让浏览器积累一组服务器特有的信息，每次访问服务器都将这些信息提供给它。因为浏览器要负责存储 cookie 的信息，所以此系统被称为客户端侧状态（client-side state）。这个 cookie 规范的正式名称为 HTTP 状态管理机制（HTTP state management mechanism）。 不同的站点使用不同的 cookie浏览器内部的 cookie 罐中可以有成百上千个 cookie，但浏览器不会将每个 cookie 都发送给所有的站点。 浏览器只会向服务器发送该服务器产生的那些 cookie。 cookie 的属性domain产生 cookie 的服务器可以向 Set-Cookie 响应头部添加一个 Domain 属性来控制哪些站点可以看到其设置的 cookie。 Set-Cookie: user=&quot;lizhiyao&quot;; domian=&quot;lizhiyao.me&quot; path可以通过 Path 属性将 cookie 与 Web 站点的部分页面关联起来。 用户登录参考《HTTP 权威指南》]]></content>
      <tags>
        <tag>查缺补漏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[api 规范]]></title>
    <url>%2F2016%2F11%2F24%2Fapi-specification%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Java]]></title>
    <url>%2F2016%2F11%2F23%2Fjava%2F</url>
    <content type="text"><![CDATA[大学时使用最多的一门编程语言是 Java，两年多没写了，几乎都忘了。现在想重新捡起来这门语言。 大学时还学过 C++、C#、Objective-C，大四实习时还写了几个月的 PHP，加入打豆豆后写了一段时间的 Python。 问自己：为什么心中总有再学习一遍 Java 的念头? 或许因为： 骨子里我把自己定位为 全栈。 Node.js 虽然也可以做后台，但它不是万能灵药。它最适合用来做的是数据密集型实时（data-intensive real-time）程序。 我认为作为开发者，应该掌握一门强类型的“标准的”面向对象的编程语言。 印象中，Java 是目前自己接触过最友好的一门语言。 先装 JDK, 确认 Java 环境变量配置正确，再装一个 eclipse 作为 Java 代码编辑器还是记得的。 配置环境变量Windows计算机 - 属性 - 高级系统设置 - 环境变量 - 系统变量 JAVA_HOME 新增 配置JDK安装路径 eg: C:\Program Files\Java\jdk1.8.0_20 PATH 修改 配置JDK命令文件的位置 eg: win10直接编辑即可，新增 C:\Program Files\Java\jdk1.8.0_20\bin CLASSPATH 新增 配置类库文件的位置 eg: .;C:\Program Files\Java\jdk1.8.0_20\lib 验证是否安装成功：在命令行分别输入 java 和 javac，每个命令输入好并点击回车后有相应的使用说明，即为安装成功。 MacLinux JVM、JRE、JDK JVM（Java Virtual Machine）Java虚拟机 JRE (Java Runtime Environment) Java运行时环境 JDK (Java Development Kit) Java开发工具包 JDK 包含 JRE，JRE包含JVM 下面进入正题： Java 的工作方式源代码 - 编译器（javac）- 字节码（平台无关）- 运行（JVM） 当 Java 虚拟机启动执行时，会寻找并锁定下面这个方法： public static void main (String[] args) { } 接着，JVM 会执行 main 方法的 {} 中的所有指令。 每一门语言都会涉及到的基础关键字、标识符、变量、流程控制语句 类和对象对象当在设计类时，要记得对象是靠类的模型塑造出来的。 可以这样看： 对象是已知的事物 对象会执行动作 对象本身已知的事物被称为 实例变量（instance variable）。它们代表对象的状态（数据），且该类型的每一个对象都会独立的拥有一份该类型的数据。所以也可以把对象当做实例。 对象可以执行的动作称为 方法（methods）。 货真价实的面向对象的 Java 应用程序，只会让对象与对象交互（这里的交互是指互相调用方法）。 Java 程序在执行期是一组会互相交谈的对象。 类类是对象的蓝图。 main() 的两种用途 测试真正的类 启动 Java 应用 变量变量必须拥有类型以及名称。 boolean、char、byte、short、int、long、float、double 数组数组也是对象 int nums; nums = new int[7]; 写惯了 JavaScript 的人要先看一下在 Java 中， 每句话后面分号是必须的 字符串（String）用双引号，字符（Char）用单引号]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[typescript]]></title>
    <url>%2F2016%2F11%2F22%2Ftypescript%2F</url>
    <content type="text"><![CDATA[安装npm install -g typescript 参考TypeScript 官网TypeScript 中文网]]></content>
      <tags>
        <tag>typescript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[保留一个空目录在 Git 版本库上]]></title>
    <url>%2F2016%2F11%2F22%2Fgitkeep%2F</url>
    <content type="text"><![CDATA[#方法 在空目录下放一个名字为 .gitkeep 的文件。 参考http://stackoverflow.com/questions/7229885/what-are-the-differences-between-gitignore-and-gitkeep]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react native]]></title>
    <url>%2F2016%2F11%2F21%2Freact-native%2F</url>
    <content type="text"><![CDATA[安装参照 这里 进行安装即可。 运行项目To run your app on iOS: cd /Users/lizhiyao/Documents/learn/react_native/AwesomeProject react-native run-ios or Open /Users/lizhiyao/Documents/learn/react_native/AwesomeProject/ios/AwesomeProject.xcodeproj in Xcode Hit the Run button To run your app on Android: Have an Android emulator running (quickest way to get started), or a device connected cd /Users/lizhiyao/Documents/learn/react_native/AwesomeProject react-native run-android]]></content>
      <tags>
        <tag>React Native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IE 浏览器中请求的 URL 乱码]]></title>
    <url>%2F2016%2F11%2F18%2Fdecode-chinese-which-included-in-request-url-in-ie%2F</url>
    <content type="text"><![CDATA[问题描述做 Insight 的过程中，遇到如下问题： 包含中文作为参数的 url 在 Chrome 中可以正常请求，从服务端获取数据。而在 IE 浏览器中，url 中的中文会变成莫名其妙的字符，导致从服务器端获取数据失败。 解决方案使用 encodeURI 函数对 url 进行转码。 escape、encodeURI、encodeURIComponent区别背景知识JavaScript中有三个可以对字符串编码的函数，分别是： escape、encodeURI、encodeURIComponent，相应3个解码函数：unescape、decodeURI、decodeURIComponent。 escapeescape 函数与encodeURI、encodeURIComponent是两路人。 escape 是对字符串进行编码，以便在所有的计算机上读取该字符串，而另外两个函数是对 URL 进行转码。 如果只是编码字符串，和 URL 没有任何关系，那么用escape。 encodeURI 和 encodeURIComponent语法 encodeURI(URI); encodeURIComponent(str); 如果需要编码整个 URL 并且使用这个 URL，那么应该用 encodeURI。 当需要编码 URL 中的参数的时候，那么 encodeURIComponent 是最好的选择。]]></content>
      <tags>
        <tag>bug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nvm]]></title>
    <url>%2F2016%2F11%2F17%2Fnvm%2F</url>
    <content type="text"><![CDATA[GitHub 仓库 安装使用 curl 方式： curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.32.1/install.sh | bash 使用安装某个版本的 node： nvm install node-version 使用某个版本： nvm use node-version 设置默认 node 版本 nvm alias default node-version]]></content>
      <tags>
        <tag>nvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于前端的一些思考]]></title>
    <url>%2F2016%2F11%2F08%2Fthinking-in-frontend%2F</url>
    <content type="text"><![CDATA[今年参加了 Qcon2016 上海站。三天时间，感觉今天会场比较火热的几个词是：前端、微服务、大数据、云平台。 个人对前端领域的总结为： Vue 和 Weex 比较抢眼球。 Vue2.0 在性能上比其 1.x 版本有很大提升。 Weex 野心很大，目前在手套等阿里系 app 中已经广泛使用。可能会携手阿里云构建从生产到分发的一站式服务。 React、React Native 是目前国内互联网公司尝试、在实际项目中使用最多的技术。 人们对 TypeScript 的关注度和接受程度比我预期的好很多。 3D 技术在前端领域的应用有着广阔的前景。 Progressive Web App 给前端开发者们点燃了新的希望，或者说，带来了一个新的信仰。 会永远被讨论的话题在这次会议上当然会被讨论：代码异常监控、前后端分离、性能优化······ 作为一个自身定位为全栈，目前从事前端开发工作的我，下面尝试着结合参会的收获和自身的项目经验，去写一些关于前端的思考。 开发者每天在做什么？大家会说：写新项目，修复已有项目的 bug，和产品经理对接需求，和同事们交流······在这些事情中，始终有着信息的流动。 有信息，就会有数据。或者说，信息即是数据。 进一步概括，开发者每天在进行着信息的增删改查（CRUD，Create、Retrieve、Update、Delete）。 那么，前端开发者们又在做什么？想弄清楚这个问题，需要先看看什么是「前端」。 什么是「前端」？广义上，是指一个软件产品中用户能够看到的部分。狭义上，是指 B/S 结构软件中通过浏览器呈现给用户的部分（网页）。 回想我们每一个项目的开发过程，从技术角度来看，我们每天做的工作有： 从服务器端获取数据 对从服务器获取的数据进行处理并使用 处理用户输入的数据 将各种来源数据变为一种对用户接受更友好的形式进行展示 将数据从客户端传输到服务器端 Server Broswer/App 本质上，前端开发者每天在做的同样是数据的增删改查。 综上，前端做的所有事情的最底层的支撑点是数据。 数据这一层之上，是什么呢？ 我认为是：业务逻辑。 有逻辑存在的地方，就会有一定的逻辑复杂度存在。 前端前辈们经过不懈的探索和努力，创造了很多帮助开发者们应对复杂度的框架。 框架 框架的存在是为了帮助我们应对复杂度。应用复杂度 vs 框架复杂度内在复杂度 vs 工具复杂度工具复杂度是我们为了 处理内在复杂度所做的投资。—《Vue.js 渐进式前端解决方案》尤雨溪 我把目前主流的框架粗暴地分为三个阵营： Vue.js 和 Weex React 和 React Native Angualr 和 Ionic 其中， Vue 和 React 走的是下面这条路线：可弹性伸缩的工具复杂度应对不同复杂度场景（视图层核心 + 可选的附加库/工具链）。 而 Angular 是一个大而全的框架，似乎在跟开发者说：有我就够了。（一套框架，多种平台。同时适用手机与桌面）。 Vue.js &amp; WeexVue.jsDOM 声明式or函数式的编写 状态的映射 逻辑在state之前处理 V DOM 把耗费时间的工作放在接触到真实DOM API之前 模板和JSX各有利弊 watcher相比于React导致额外内存开销，但是相比于真实DOM渲染还是小很多。Vue2比Vue1内存开销小很多。 Vue依赖追踪系统 高效精准 Weex组件嵌套不会导致性能问题，组件数量会导致。 合理细分组件，不必过度细分。 React &amp; React NativeReact优化 shouldComponentUpdate() Angualr &amp; Ionic框架背后的一些设计思想Component思想：UI结构映射到组件树 客户端路由url和应用状态应该有一个映射关系 框架的选择 Pick the right tool for the job. 应用内在复杂度 vs 工具复杂度 TypeScript在构建对健壮性要求很高的 Web 应用时，建议使用。 3D技术在前端领域的应用不熟悉，待补充。 前后端分离是合作方式上的分离，能物理隔离（代码库、进程）最好。 前端领域没有被提及的微信小应用大多数人处在观望状态。 Docker应该被广泛的使用起来。 WebAssembly（WASM）一种面向Web的二进制格式。可以作为任何编程语言的编译目标，使应用程序可以运行在浏览器或其它代理中。 使得使用任何能够编译成WASM的语言编写Web代码成为可能。 http2可能会引发一场构建工具的革命。 一些思考自动化，提高效率 取舍 不打扰过去，不高歌未来 知行合一]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Visual Studio Code的一些技巧（Mac）]]></title>
    <url>%2F2016%2F09%2F21%2Fuse-visual-studio-code-on-mac%2F</url>
    <content type="text"><![CDATA[快捷键 打开一个新窗口 shift + cmd + N 关闭某个窗口 shift + cmd + W 打开项目 cmd + O 最近打开的项目 Ctrl + R 新建一个文件 cmd + N 复制 cmd + C 粘贴 cmd + V 保存 cmd + S 撤销 cmd + Z 重做 shift + cmd + Z 格式化js代码 shift + option(alt) + F 预览Markdown shift + cmd + V 折叠某部分代码 折叠全部代码 展开某部分代码 展开全部代码 jsconfig.json在vs code下写js代码，最好在项目根目录有jsconfig.json 文件。如果没有的话，vs code界面右下角会有一个类似于灯泡的标志“亮起来”，来提示用户添加该配置文件。 点一下“亮起来“的💡，就可以快速创建一个jsconfig.json 配置文件。 node先确保项目根目录有 jsconfig.json 文件，然后依次执行如下命令。 npm install -g typings typings install dt~node --global --save typings install env~node --global --save 参考官方文档Visual Studio Code 中文手册Node.js Applications with VS Codetypings]]></content>
  </entry>
  <entry>
    <title><![CDATA[Mac上MySQL的基本使用]]></title>
    <url>%2F2016%2F09%2F18%2Fthe-basic-use-of-mysql-on-the-Mac%2F</url>
    <content type="text"><![CDATA[安装（使用 Homebrew 安装）$ brew update $ brew install mysql 启动brew services start mysql 登录默认情况下，MySQL 用户 root 没有密码： mysql -uroot 有密码的情况下登录： mysql -u root -p 修改 root 用户的密码mysqladmin -u root password &apos;new-password&apos; 常用命令 退出 exit 显示数据库列表 show databases; 显示数据库中的表 use mysql; show tables; 显示数据表的结构：describe table_name; 建库 create database 库名; 删库 drop database 库名; 导入数据 mysql -u user -p&#39;password&#39; db_name &lt; table_name.sql 如果以上过程都不想做，那就去使用XAMPP吧]]></content>
  </entry>
  <entry>
    <title><![CDATA[IE11 点击label标签中的img标签选中input失效]]></title>
    <url>%2F2016%2F09%2F10%2Fimg-and-label-for-input-in-a-form-not-clickable-in-IE11%2F</url>
    <content type="text"><![CDATA[问题描述这个问题用中文描述不容易让人知道是什么问题（比如上面的标题），或许英文描述更好明白是什么问题：img and label for input in a form not clickable in IE11. 如果看了英文还是不清楚问题，那么只能上代码了： &lt;form&gt; &lt;label&gt; &lt;input type=&quot;checkbox&quot;&gt; some text &lt;img src=&quot;&quot;&gt; &lt;/label&gt; &lt;/form&gt; 或者 &lt;form&gt; &lt;input type=&quot;checkbox&quot; id=&quot;test&quot;&gt; some text &lt;label for=&quot;test&quot;&gt; &lt;img src=&quot;&quot;&gt; &lt;/label&gt; &lt;/form&gt; 如上，无论是checkbox还是radio，在IE11中点击img标签，均无法选中input。 解决办法css方式注意：在微信浏览器中，应用了pointer-events: none的img标签，如果src属性的值是一个包含二维码的图片，长按识别二维码功能会失效。 label { display: inline-block; } label img { display: block; /* fix */ pointer-events: none; } js方式（个人不喜欢这种方式）根据DOM的结点关系，给相应的DOM结点绑定点击事件。 参考http://stackoverflow.com/questions/20198137/image-label-for-input-in-a-form-not-clickable-in-ie11http://stackoverflow.com/questions/20524815/ie-11-bug-image-inside-label-inside-form]]></content>
  </entry>
  <entry>
    <title><![CDATA[Android 应用无法打开某网页的原因之一]]></title>
    <url>%2F2016%2F09%2F01%2Fcan-not-open-a-web-pages-in-android-app%2F</url>
    <content type="text"><![CDATA[问题描述丁香园 app 安卓版可以打开旧版调查问卷网页，但是打不开新版调查问卷网页。 iOS 版可以正常打开旧版和新版的问卷。 Android 开发环境报错： “Uncaught TypeError: Cannot read property ‘getItem’ of undefined”。 和 app 的安卓开发去确认，app 是否设置了支持 js 代码执行，被告知已经设置支持。 问题原因作为 HTML5 标准的一部分，绝大多数的浏览器都是支持 localStorage 的， 但是鉴于它的安全特性（任何人都能读取到它，尽管有相应的限制，将敏感数据存储在这里依然不是明智之举），Android 默认是关闭该功能的。 解决方案在 Android 项目代码中，增加： webView.getSettings().setDomStorageEnabled(true); 参考http://stackoverflow.com/questions/4930623/webview-causing-uncaught-typeerror-when-loading-www-google-comhttp://ryanhoo.github.io/blog/2014/09/17/android-webview-setdomstorageenabled/]]></content>
  </entry>
  <entry>
    <title><![CDATA[书法之路]]></title>
    <url>%2F2016%2F08%2F23%2Fcalligraphy-road%2F</url>
    <content type="text"><![CDATA[第一次接触钢笔书法，是初中的时候。班主任是语文老师，重视大家写字的漂亮程度，她还给大家请了一位教书法的老师。我是从那个时候开始接触钢笔字最基本的笔画，比如：垂露竖、悬针竖等。 遗憾的是，书法老师教我们一段时间后就不教了。 高中和大学期间，没记错的话，共买了三本字帖。断断续续的练着。 进入丁香园后，加入了书法小分队，有幸遇到了一些喜欢书法的同事。24岁的我，也重新拾起了钢笔。 很喜欢这句话： Find what u really love, and let kill u. 对于书法，目前的我还谈不上热爱，但是代码之余，静下心来去写点字，确实是一件惬意的事情。写字的过程中，整个世界都变得安静了，没有烦恼和压力，似乎有时候可以体会到一点点‘心静自然凉’的味道。 或者，促使我再次拾起钢笔的是这个原因：觉得万事万物是相通的。整个人生就如同在纸上写字一般。我需要反复的磨砺心态，感悟道理，去朝着知行合一的目标努力。 现将一些书法路上的心得记录如下： 入门目前的我，也就是处在钢笔书法的入门阶段。 对自己的评价： 感觉基本功不到家 笔划的书写不够纯熟、美观；手有的时候不听使唤；通篇写下来 一眼望去的直观感受就是 不好看。 周总的建议是： 那就慢些，少写几个，注意力集中些 一般集中注意一段时间人都会疲劳，初学者有手部疲劳或者注意力涣散都不宜练字]]></content>
  </entry>
  <entry>
    <title><![CDATA[api version control]]></title>
    <url>%2F2016%2F08%2F19%2Fapi-version-control%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Apache的基本使用（Mac）]]></title>
    <url>%2F2016%2F08%2F19%2Fuse-apache-on-mac%2F</url>
    <content type="text"><![CDATA[Mac下自带了Apache。 查看Apache版本apachectl -v 启动Apachesudo apachectl start 关闭Apachesudo apachectl stop 重启Apachesudo apachectl restart 通过浏览器访问 http://127.0.0.1/ ，可以看到内容为“It works!”的页面，即为启动成功。 安装目录/etc/apache2/ 默认根目录/Library/WebServer/Documents 设置虚拟主机配置hostssudo vi /etc/hosts]]></content>
  </entry>
  <entry>
    <title><![CDATA[learn vue.js]]></title>
    <url>%2F2016%2F08%2F10%2Flearn-vue-js%2F</url>
    <content type="text"><![CDATA[Vue.js 中文官网 官方已经说得很清楚了，下面做一个速记，用于提高自己的使用效率吧。 项目初始化对于熟悉使用 Node.js 和 Webpack 构建前端项目，尤其是使用过 React 或者 Angualr 的人来说，直接就用 vue-cli 吧。 vue-cli安装npm install -g vue-cli 使用Usage: vue &lt;command&gt; [options] Commands: init generate a new project from a template list list available official templates help [cmd] display help for [cmd] Options: -h, --help output usage information -V, --version output the version number 初始化一个项目# create a new project with an official template vue init webpack my-project 运行初始化的项目cd my-project npm install npm run dev]]></content>
      <tags>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于React构建大中型Web应用]]></title>
    <url>%2F2016%2F07%2F30%2Fa-project-with-react-redux-webpack-es6%2F</url>
    <content type="text"><![CDATA[最近基于React + Redux + Webpack + ECMAScript6做了丁香调查新版问卷项目。 整个问卷前后端分离，前端渲染完全由数据驱动。 现将经验总结如下： 大体的分享思路为：技术选型说明 -&gt; 简单介绍React -&gt; 使用ES6编写React组件 -&gt; Redux -&gt; 整个项目的工程化构建 -&gt; 一些小技巧 -&gt; 反思总结 项目要求 前后端分离 移动端、pc端使用同一套代码，要求等比例缩放页面 除IE8及IE8以下版本浏览器不需要支持，其余浏览器要表现良好 尽可能减少后期维护成本 支持问卷的二次定制 项目特点两个字即可以概括：复杂 交互 业务逻辑 技术方案React + Redux + Webpack + ECMAScript6 选择该技术方案原因选择的原则：选择最合适的 确定方案之前，可选择方案主要有： 使用操作DOM的js库。比如：jQuery/Zepto 使用MVC（MVVM）框架。比如：Backbone、Angular 使用专注于MVC中View层（界面）的解决方案。比如：Vue、React 排除其他方案的主要理由： jQuery（write less do more） 仅仅是一个js库，不适合做交互和业务逻辑很复杂的大中型项目 每个人编写的代码质量不同，风格不同增加了维护成本。 题外话： jQuery/Zepto会慢慢（or 已经）过时 过时不代表你就一定不可以再用，或者要从现有项目中清除抛弃掉。项目维护和管理本身是另一回事情，并不是完全由技术因素决定的。 Backbone 要定义多个类才能实现一个功能 每个人编写的代码质量不同，风格不同增加了维护成本。 Angular 过重 移动端性能 短期内团队成员接手维护困难 Vue Vue.js 不支持 IE8 及其以下版本，因为 Vue.js 使用了 IE8 不能实现的 ECMAScript 5 特性 项目浏览器兼容要IE8+ 短期内团队成员接手维护困难 ReactReact 本身其实还算简单的。 从面向对象编程的角度，一切皆为对象（Object）。对象由一个类（Class）有自己的 属性 和 方法。 延展到React中： 类 —&gt; 组件（Component）属性 —&gt; state 和 props方法 —&gt; 方法 最简单的理解，一个组件的渲染函数就是一个基于 state 和 props 的纯函数，state 是自己的，props 是外面来的，任何 state 或者 props 变了就重新渲染一遍。 一个例子： 我这个人在大千世界中就可以看做为一个 组件（Component）。 我有自己的属性（props），比如：性别男；有两只手；出生在吉林… 我还有自己的状态（state），比如：第一次在团队中做技术分享时，是略紧张并快乐的；16年夏天的我是一个胖子；近视… 如何区分state 和 props？ 简单地对每一项数据提出三个问题： 是否是从父级通过 props 传入的？如果是，可能不是 state 。是否会随着时间改变？如果不是，可能不是 state 。能根据组件中其它 state 数据或者 props 计算出来吗？如果是，就不是 state 特点 作为MVC架构的V层。可以在新项目中完全使用React，也可以作为一个小特征轻易地在已有项目中使用。 虚拟DOM 单向响应的数据流 Declarative(声明式) 代码运行效果可预测性更高，更容易debug。(声明式的把视图组件写好，当数据变化时，React去负责正确的渲染页面且仅会更新变化的部分。) Component-Based Learn Once, Write Anywhere 服务端Node.js渲染/Ract Native JSX（JavaScript XML）当对React组件有了基本的概念之后，我们可以设想一下：我们现在已经有了一个用来创建Views的组件（类），如果这个组件可以做到渲染出页面，那么必然会有一个用于渲染的方法。 如果是我们自己来实现这样一个渲染方法，大概做法是：渲染方法中接收state 或者 props，返回一坨html字符串。 回想在使用jQuery中，或许我们写过很多次类似的函数。 但是这类函数有一些弊端：不易阅读、容易出错、难以复用… So，创作React的那群哥们儿弄出来一个叫JSX的东西。 JSX 是 JavaScript语法糖。仅此而已，如果非得加一个词来描述这个语法糖，那就是 好用的 语法糖。 对语言功能没有影响，旨在提高代码可读性，使开发者更容易使用，减少代码出错的概率。 还要多少年, 前端开发才能像客户端开发那样轻松？ 生命周期 人（组件）是会生老病死的。无论是在哪一个状态，都是有一些方法来改变这个人（组件）的。 — 李小帅 目的：挂载、更新、移除阶段 改变组件 如何创建一个React组件第一步：拆分用户界面为一个组件树 单一功能原则：理想状态下一个组件应该只做一件事，假如它功能逐渐变大就需要被拆分成更小的子组件。 检查数据模型结构是否正确。这是因为用户界面和数据模型在 信息构造 方面都要一致，这意味着将你可以省下很多将 UI 分割成组件的麻烦事。你需要做的仅仅只是将数据模型分隔成一小块一小块的组件，以便它们都能够表示成组件。 第二步： 利用 React ，创建应用的一个静态版本 将数据模型渲染到 UI 上，但是没有交互功能 仅通过 props 传递数据（state 仅用于实现交互功能） 第三步：识别出最小的（但是完整的）代表 UI 的 state 关键点在于精简：不要存储重复的数据。 第四步：确认 state 的生命周期明确哪个组件会改变或者说拥有这个 state 数据模型。 第五步：添加反向数据流 传递一个回调函数 ReactLink插件 示例Footer组件 ECMAScript6let/constlet 用来声明变量 用法类似于var 所声明的变量，只在let命令所在的代码块内有效 for循环的计数器，很合适使用let 不存在变量提升。变量一定要在声明后使用，否则报错 不允许重复声明 const 声明一个只读的常量 一旦声明，常量的值就不能改变 解构赋值 ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。 注意，ES6内部使用严格相等运算符（===），判断一个位置是否有值。所以，如果一个数组成员不严格等于undefined，默认值是不会生效的。 解构可用于数组、对象、字符串、数字、布尔值、函数的参数。 示例： 1234var user_info = this.props.user_info;var survey_info = this.props.survey_info;var items_info = this.props.items_info;var buttons_info = this.props.buttons_info; 1const &#123; user_info, survey_info, items_info, buttons_info &#125; = this.props; or 1import &#123; connect &#125; from 'react-redux'; 字符串的扩展模板字符串传统的JavaScript语言，输出模板通常是这样写的。 123456$('#result').append( 'There are &lt;b&gt;' + basket.count + '&lt;/b&gt; ' + 'items in your basket, ' + '&lt;em&gt;' + basket.onSale + '&lt;/em&gt; are on sale!'); 上面这种写法相当繁琐不方便，ES6引入了模板字符串解决这个问题。 12345$('#result').append(` There are &lt;b&gt;$&#123;basket.count&#125;&lt;/b&gt; items in your basket, &lt;em&gt;$&#123;basket.onSale&#125;&lt;/em&gt; are on sale!`); 函数的扩展箭头函数 ES6允许使用“箭头”（=&gt;）定义函数。 示例：123let mapStateToProps = (state, ownProps) =&gt; &#123;&#125; or12345678910111213const &#123; optionvalue &#125; = this.props.item;let info = &#123; rates: [], unknow: []&#125;;optionvalue.forEach(optionObj =&gt; &#123; if (isNaN(parseInt(optionObj.label))) &#123; info.unknow.push(optionObj); &#125; else &#123; info.rates.push(optionObj); &#125;&#125;); 对象的扩展属性的简洁表示法 ES6允许直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。ES6允许在对象之中，只写属性名，不写属性值。这时，属性值等于属性名所代表的变量。 1234567891011121314let mapStateToProps = (state, ownProps) =&gt; &#123; let fields = []; // some code const validate = (values, props) =&gt; &#123; // some code &#125;; return &#123; fields, validate &#125;;&#125; 属性名表达式 如果使用字面量方式定义对象（使用大括号）, 用表达式作为对象的属性名，即把表达式放在方括号内。 1234// 实时存储realtimeStorage &amp;&amp; realtimeStorage(&#123; [field.name]: field.value&#125;); Object.is() 用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。不同之处只有两个：一是+0不等于-0，二是NaN等于自身。 12345+0 === -0 //trueNaN === NaN // falseObject.is(+0, -0) // falseObject.is(NaN, NaN) // true Object.assign() Object.assign方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。 注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。 Object.assign拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（enumerable: false）。 Object.assign方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。 1Object.assign(target, source1, ..., sourcen); 示例：123case QuestionTypes.RATE_MIX: Object.assign(errors, mixValidator(item, values)); break; 常见用途 对象的扩展运算符 ES7有一个提案，将Rest解构赋值/扩展运算符（…）引入对象。Babel转码器已经支持这项功能。 示例：1234567&lt;input type=&#123; inputType &#125; autoComplete="off" className="input-single-text" disabled=&#123; disabled &#125; &#123;...field&#125; onBlur=&#123;this.handleBlur.bind(this) &#125; /&gt; or 1let copyState = &#123;...state&#125;; Set和Map数据结构Set示例：1234567891011// 用户输入重复值验证let values = [];for (let itemid in fieldValues) &#123; if (fieldValues[itemid]) &#123; values.push(fieldValues[itemid]); &#125;&#125;const set = new Set(values);if (set.size &lt; values.length) &#123; errorInfo = '答案内容请勿重复';&#125; Map示例： 12345678910111213case QuestionTypes.RATE_MIX:const rateFields = new Map();item.post_info.forEach(itemid =&gt; &#123; rateFields[itemid] = fields[itemid];&#125;);question = &lt;RateMix key=&#123;index&#125; id=&#123;num&#125; item=&#123;item&#125; fields=&#123;rateFields&#125; touch=&#123;touch&#125; realtimeStorage=&#123;realtimeStorageFunc&#125; /&gt;;break; Class 基本上，ES6的class可以看作只是一个语法糖，它的绝大部分功能，ES5都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。 Class之间可以通过extends关键字实现继承，这比ES5的通过修改原型链实现继承，要清晰和方便很多。 1234567891011121314151617import &#123; Component &#125; from 'react';class App extends Component &#123; constructor(props) &#123; super(props); // code &#125; changePreviewInfo(itemid) &#123; // code &#125; render() &#123; // code &#125;&#125; 修饰器 修饰器（Decorator）是一个函数，用来修改类的行为。这是ES7的一个提案，目前Babel转码器已经支持。 修饰器对类的行为的改变，是代码编译时发生的，而不是在运行时。 示例：123456789101112import &#123; sortable &#125; from 'react-anything-sortable';@sortableclass SortableItem extends React.Component &#123; render() &#123; return ( &lt;div &#123;...this.props&#125;&gt; &#123;this.props.children&#125; &lt;/div&gt; ); &#125;&#125; ModuleJavaScript开发大型的、复杂的项目的巨大障碍：没有模块（module）体系。 ES6之前，社区制定了一些模块加载方案： 浏览器 AMD 服务器 CommonJS ES6在语言规格的层面上，实现了模块功能，而且实现得相当简单，完全可以取代现有的CommonJS和AMD规范，成为浏览器和服务器通用的模块解决方案。 ES6模块的设计思想，是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS和AMD模块，都只能在运行时确定这些东西。 Node的默认模块格式是CommonJS，目前还没决定怎么支持ES6模块。所以，只能通过Babel这样的转码器，在Node里面使用ES6模块。 export default命令其他模块加载通过export default命令导出的模块时，import命令可以为该匿名函数指定任意名字。 模块的整体加载示例： 1import * as QuestionTypes from '../../constants/QuestionTypes'; Redux跨组件通信？多组件共享状态？多人协作的可维护性？ 通熟易懂的redux教程一份 React 设计思想 WebpackWebpack入门 区分开发和生产环境图片按需加载12345678module: &#123; loaders: [ &#123; test: /\.(png|jpg)$/, loader: 'file?hash=sha512&amp;digest=hex&amp;name=[path][name].[ext]?v=[hash]' &#125; ]&#125; publicPath异步请求的状态管理每道题可能发n个请求，题目内请求取最新即可。 题目间请求结果（最好）保证有序执行。 前端log系统及时发现并定位bug、记录异常 一些技巧和处理方案Babelwebpack-dev-servercross-env统一Mac、Linux、Windows命令行的差异 reqwestredux-form高阶函数的使用示例：表单预览 移动端、PC端判断判断： 123if (ua.indexOf("Android") != -1 || ua.indexOf("iPhone") != -1 || ua.indexOf("iPad") != -1) &#123; window.isMobile = true;&#125; 使用： 配合classnames 123456789import classnames from 'classnames';&lt;div className=&#123; classnames(&#123; "pc": !window.isMobile &#125;)&#125;&gt; &#123; this.props.children &#125;&lt;/div&gt; 配合级联组件使用： 12345const DesktopOrMobile = window.isMobile ? 'Mobile' : 'Desktop';cascadeArea = new Cascading[DesktopOrMobile](&#123; // some code&#125;); 浏览器类型和版本号判断1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677export default function Broswer() &#123; var _broswer = &#123;&#125;; var sUserAgent = navigator.userAgent; // console.info("useragent: ", sUserAgent); var isOpera = sUserAgent.indexOf("Opera") &gt; -1; if (isOpera) &#123; //首先检测Opera是否进行了伪装 if (navigator.appName == 'Opera') &#123; //如果没有进行伪装，则直接后去版本号 _broswer.version = parseFloat(navigator.appVersion); &#125; else &#123; var reOperaVersion = new RegExp("Opera (\\d+.\\d+)"); //使用正则表达式的test方法测试并将版本号保存在RegExp.$1中 reOperaVersion.test(sUserAgent); _broswer.version = parseFloat(RegExp['$1']); &#125; _broswer.opera = true; &#125; var isChrome = sUserAgent.indexOf("Chrome") &gt; -1; if (isChrome) &#123; var reChorme = new RegExp("Chrome/(\\d+\\.\\d+(?:\\.\\d+\\.\\d+))?"); reChorme.test(sUserAgent); _broswer.version = parseFloat(RegExp['$1']); _broswer.chrome = true; &#125; //排除Chrome信息，因为在Chrome的user-agent字符串中会出现Konqueror/Safari的关键字 var isKHTML = (sUserAgent.indexOf("KHTML") &gt; -1 || sUserAgent.indexOf("Konqueror") &gt; -1 || sUserAgent.indexOf("AppleWebKit") &gt; -1) &amp;&amp; !isChrome; if (isKHTML) &#123; //判断是否基于KHTML，如果是的话再继续判断属于何种KHTML浏览器 var isSafari = sUserAgent.indexOf("AppleWebKit") &gt; -1; var isKonq = sUserAgent.indexOf("Konqueror") &gt; -1; if (isSafari) &#123; var reAppleWebKit = new RegExp("Version/(\\d+(?:\\.\\d*)?)"); reAppleWebKit.test(sUserAgent); var fAppleWebKitVersion = parseFloat(RegExp["$1"]); _broswer.version = parseFloat(RegExp['$1']); _broswer.safari = true; &#125; else if (isKonq) &#123; var reKong = new RegExp("Konqueror/(\\d+(?:\\.\\d+(?\\.\\d)?)?)"); reKong.test(sUserAgent); _broswer.version = parseFloat(RegExp['$1']); _broswer.konqueror = true; &#125; &#125; // !isOpera 避免是由Opera伪装成的IE var isIE = sUserAgent.indexOf("compatible") &gt; -1 &amp;&amp; sUserAgent.indexOf("MSIE") &gt; -1 &amp;&amp; !isOpera; if (isIE) &#123; var reIE = new RegExp("MSIE (\\d+\\.\\d+);"); reIE.test(sUserAgent); _broswer.version = parseFloat(RegExp['$1']); _broswer.msie = true; &#125; // 排除Chrome 及 Konqueror/Safari 的伪装 var isMoz = sUserAgent.indexOf("Gecko") &gt; -1 &amp;&amp; !isChrome &amp;&amp; !isKHTML; if (isMoz) &#123; var reMoz = new RegExp("rv:(\\d+\\.\\d+(?:\\.\\d+)?)"); reMoz.test(sUserAgent); _broswer.version = parseFloat(RegExp['$1']); _broswer.mozilla = true; &#125; return _broswer;&#125;// 调用// var broswer = Broswer();// console.info("broswer.version: ", broswer.version);// console.info("broswer.msie is ", broswer.msie);// console.info("broswer.safari is ", broswer.safari);// console.info("broswer.opera is ", broswer.opera);// console.info("broswer.mozilla is ", broswer.mozilla);// console.info("broswer.chrome is ", broswer.chrome);// console.info("broswer.konqueror is ", broswer.konqueror); Google Analytics没有采用由后台添加到页面，而是前端直接在js代码中添加如下代码： 1234567// Google Analytics(function (i, s, o, g, r, a, m) &#123; i['GoogleAnalyticsObject'] = r; i[r] = i[r] || function () &#123; (i[r].q = i[r].q || []).push(arguments) &#125;, i[r].l = 1 * new Date(); a = s.createElement(o), m = s.getElementsByTagName(o)[0]; a.async = 1; a.src = g; m.parentNode.insertBefore(a, m)&#125;)(window, document, 'script', '//www.google-analytics.com/analytics.js', 'ga'); 初始化： 1ga('create', userId, 'auto'); 页面打点： 1ga('send', 'pageview', url); 事件打点： 1ga('send', 'event', eventCategory, action); 微信分享带缩略图“作弊方法”分享网页到朋友圈带缩略图 常规方法移动端、PC端两套样式方案：通过 classnames 和 window.isMobile 决定应用根组件的class名，然后使用less来定制某一端的样式即可。 应用根组件： import React from &apos;react&apos;; import classnames from &apos;classnames&apos;; export default class Div extends React.Component { render() { const { app_root } = this.props; return ( &lt;div className={ classnames({ &quot;app-root&quot;: app_root, &quot;pc&quot;: !window.isMobile, &quot;preview&quot;: window.preview }) }&gt; { this.props.children } &lt;/div&gt; ); } } 隐藏IE浏览器输入框自带的清除按钮input::-ms-clear { display: none; } 自动定位有错误的题目在渲染题目时，给其 id 属性，根据 id 获取错误题目的坐标 (x, y) window.scroll(x, y); 总结收获 整个应用由数据驱动，更快的定位bug 较低的后期维护成本 一套可复用的React组件 不足 较少的使用 PropTypes 缺少静态类型检测（Typescript） 缺少测试代码 编码风格与小组规范不统一 应该使用react-router 经验应用数据结构的设计很重要 数据结构尽可能扁平化 类型检查很重要 外来的数据一定要验证数据类型，格式正确才可以继续往下走。 不要完全相信后台给过来的数据。 尽可能记录下来沟通结果方便出问题时进行沟通 解决问题方法 不要带着情绪去解决问题 或许需要的仅仅是休息五分钟，或者暂时放下这个问题明天再做 再认真冷静的读一读官方文档 Google 联系作者（Github、Email等） 请教身边伙伴 沟通 目标：为了高效合理的解决问题 与后台： 某功能的实现由谁来做？ 性能问题？ 改接口（数据格式、增删字段） 与产品： 某功能更合适（代码角度、设计角度等）的实现方案 时间节点 按时/提前高质量完成PM最重要 反思React带给我们了什么？ 组件化开发方式的一些思考 高度易维护 …… Redux带给我们了什么？ 大大减低了状态的保存与管理的成本，此外我们还可以通过一定的手段，复现过去的动作。 …… 技术参考React - 用于构建用户界面的JAVASCRIPT库 Thinking in React Redux 中文文档 Redux Form - The best way to manage your form state in Redux. Webpack 中文指南 ECMAScript 6入门]]></content>
  </entry>
  <entry>
    <title><![CDATA[MongoDB 基础]]></title>
    <url>%2F2016%2F07%2F20%2Fmongodb%2F</url>
    <content type="text"><![CDATA[下载下载地址 安装Windowswindows平台下，有.msi安装程序。下载安装文件按照提示安装即可。 创建并启动数据库假设mongodb安装目录为 D:\MongoDB，在MongoDB文件夹里新建blog文件夹，作为博客内容的存储目录。 打开命令行，切换到 D:\MongoDB\bin，输入以下命令来设置blog文件夹作为项目的存储目录并启动数据库： mongod -dbpath D:\MongoDB\blog 为了方便以后使用数据库，在桌面上建立MongoDB.bat，并写入： D:\MongoDB\bin\mongod.exe -dbpath D:\MongoDB\blog 以后只需运行MongoDB.bat，就可以启动数据库了 Mac (使用Homebrew安装)参考https://docs.mongodb.com/manual/tutorial/install-mongodb-on-os-x/ 安装 brew install mongodb –with-openssl Generally there are no consequences of this for you. If you build yourown software and it requires this formula, you’ll need to add to yourbuild variables: LDFLAGS: -L/usr/local/opt/openssl/lib CPPFLAGS: -I/usr/local/opt/openssl/include To have launchd start mongodb now and restart at login: brew services start mongodb Or, if you don’t want/need a background service you can just run: mongod --config /usr/local/etc/mongod.conf 创建数据库文件存放目录 sudo mkdir -p /data/db 给db目录读写权限 启动数据库 mongod MongoDB shellMongoDB Shell是MongoDB自带的交互式Javascript shell,用来对MongoDB进行操作和管理的交互式环境。当你进入mongoDB后台后，它默认会链接到 test 文档（数据库）。 进入 mongo 退出 Ctrl+C 命令行帮助 mongo -h 显示所有数据的列表 show dbs 显示当前数据库对象或集合 db 创建/连接到一个指定的数据库（如果数据库不存在，则创建数据库，否则切换到指定数据库。） use dbName 删除数据库（先切换到要删除的数据库） db.dropDatabase() MongoDb web 用户界面MongoDB 提供了简单的 HTTP 用户界面。 如果你想启用该功能，需要在启动的时候指定参数 --rest 。 ./mongod --dbpath=/data/db --rest MongoDB 的 Web 界面访问端口比服务的端口多1000。 如果你的MongoDB运行端口使用默认的27017，你可以在端口号为28017访问web用户界面，即地址为：http://localhost:28017。]]></content>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ios 微信浏览器中禁止自动识数字别为电话链接]]></title>
    <url>%2F2016%2F07%2F15%2Fios-number-telephone-in-wechat%2F</url>
    <content type="text"><![CDATA[全局禁止方法1&lt;meta name="format-detection" content="telephone=no" /&gt; 全局禁止后 希望识别某些电话号码能够链接到iPhone的拨号功能1&lt;a href="tel:13800138000"&gt;13800138000&lt;/a&gt; 参考How to disable phone number linking in Mobile Safari? 关闭Android/iPhone浏览器自动识别数字为电话号码]]></content>
  </entry>
  <entry>
    <title><![CDATA[Selenium]]></title>
    <url>%2F2016%2F07%2F06%2FSelenium%2F</url>
    <content type="text"><![CDATA[介绍Selenium是浏览器自动化工具，我们可以用它来驱动功能测试。确保所安装的是最新版本。Selenium一直紧跟主流浏览器的更新步伐，尝试使用最新功能。如果发现Selenium由于某些原因表现异常，通常都是因为Firefox的版本太新，此时应该升级到最新版的Selenium。 python 环境安装pip3 install --upgrade selenium Mac下配合Chrome使用from selenium import webdriver browser = webdriver.Chrome() browser.get(&apos;http://localhost:8000&apos;) Mac下可能会报错：AttributeError: ‘Service’ object has no attribute ‘process’ 解决方案： brew install chromedriver 参考：http://stackoverflow.com/questions/8255929/running-webdriver-chrome-with-selenium/8259152#8259152 相关 TDD（Test-Driven Development），测试驱动开发 在TDD的过程中，第一步始终一样：编写测试 测试山羊的教诲：没有测试什么也别做。像山羊一样咩咩的叫着：“先测试，先测试！” 山羊的另一个特点是：一次只迈一步。因此，不管山腰多么陡峭，他都不会跌落。]]></content>
      <tags>
        <tag>编程工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[贪小便宜吃大亏]]></title>
    <url>%2F2016%2F06%2F05%2F%E8%B4%AA%E5%B0%8F%E4%BE%BF%E5%AE%9C%E5%90%83%E5%A4%A7%E4%BA%8F%2F</url>
    <content type="text"><![CDATA[刚入职那段时间，如果晚点从公司走的话，需要步行近半个小时回住的地方。 步行应该是一种比较健康的上下班方式了。不过步行的次数多了，对于我这种异常珍惜宝贵的时间的程序员来说，难免觉得花在路上的时间太多了。把时间花在路上，还不如用来多写几个bug，哦，不对，还不如用来…用来做什么都比花在路上强吧。 上一段纯属戏言。其实让自己产生买一辆自行车想法的直接原因是：一个人走路略无趣，觉得如果有一辆车陪伴就会好很多，并且原本自己就是一个喜欢各种车的人。 决定买自行车，而不是电动车、汽车的原因也很简单：自己挺喜欢骑自行车的那种感觉。再深层次的原因，就是个人经济问题了。 就这样，在阳光明媚的某天，午睡后毅然决然的打开手机，准备去58同城淘一辆二手自行车。看中一辆转转平台上的捷安特自行车，就这样乖乖的被58同城导流到了58转转。 车主的描述说这辆自行车是公司年会发的，有正规发票，因为自己不需要，所以想转掉。车子描述用了一堆专业名词，最后直击我的痛点的是价格：680。 一辆95成新的捷安特，有正规发票，680。感觉这就是我想买的那辆自行车。冥冥中觉得自己如果可以680入手，似乎还捡了一个不小的便宜。 联系车主，约定交易地点，试骑，一手交钱一手交货，一切都是那么的顺利。我还好奇的问了那个人，为什么要处理掉这辆车？得到的答复是，她住的地方离公司太远，用不到这辆自行车。 接下来，我就高高兴兴把车骑回家，一路上吸了不少由于杭州的拆建而引起的灰尘。 骑回来的路上，发现车的一点小问题是变速器不太好用。以为自己不懂山地车的变速，不会使用变速器，也就没太在意。 有一天，车子放在公司楼下，突然下起了雨，小雨一下就是几天。雨过天晴后，发现车子有几处地方已经生锈了。自己有点诧异。原以为捷安特的自行车不会这么容易生锈的。转念一想，再强的人也会有累的时候，被雨浇了就会生锈，正常。 又过了一段时间，发现脚踏板附近每骑一圈，就会发出一次“咯吱”的声响。猜想或许是被雨淋了，脚踏板缺油了，找时间上点油应该就会不响了。为了不听“咯吱咯吱的”声响，每次骑行都带上耳机。 就在昨天，准备和同时一起骑行到西湖时，由于路上会和同事交谈，带耳机不方便，就没有带耳机。突然发现，“咯吱”的响声已经特别大了。 终于写到了高潮。高潮是：骑行路上找了一家捷安特专卖准备维修时，被告知这辆车是假的。 在故事达到高潮的那一刻，觉得自己又成长了。有那么瞬间，不知道自己在想什么，也记不得身边的人在说什么。用长者的话来形容自己：naive。 n年之前就告诫过自己或者被别人告诫过：贪小便宜吃大亏。生意场上，一分钱一分货还是有道理的。 知行合一这事儿，还是得继续修炼。 我就是一个普通人，天上掉馅饼这件事情，有生之年不会再我身上发生。如果有，我需要做的是躲得离馅饼远一点，以免被砸伤。 后记： 前几天，把自行车以140的价格将车子转手给同事了。 买东西之前要三思，三分钟热度的东西要敬而远之。]]></content>
      <tags>
        <tag>自省</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Module version mismatch]]></title>
    <url>%2F2016%2F06%2F05%2FModule-version-mismatch%2F</url>
    <content type="text"><![CDATA[Bug描述更新node版本后，使用hexo命令，遇到如下问题： 解决方案根据报错信息找出报错的node包，将其remove并重新安装 参考http://stackoverflow.com/questions/15584529/module-version-mismatch-expected-11-got-1]]></content>
      <tags>
        <tag>Bugs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[homebrew]]></title>
    <url>%2F2016%2F06%2F02%2Fhomebrew%2F</url>
    <content type="text"><![CDATA[安装/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 更新brew update 卸载ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/uninstall)&quot; 参考http://brew.sh/ http://superuser.com/questions/203707/how-to-uninstall-homebrew-mac-os-x-package-manager]]></content>
      <tags>
        <tag>homebrew</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack学习笔记]]></title>
    <url>%2F2016%2F03%2F29%2Fwebpack%2F</url>
    <content type="text"><![CDATA[前言以下内容为小帅在学习Webpack过程中整理的笔记。持续完善中… Demo的Github地址 Webpack是什么简而言之，Webpack是一个模块化管理和打包前端资源的工具。 它可以将许多松散的模块按照依赖和规则打包成符合生产环境部署的前端资源， 还可以将按需加载的模块进行代码分隔，等到实际需要的时候再异步加载。 通过加载器（loader）的转换，任何形式的资源都可以视作模块，比如 CommonJs 模块、 AMD 模块、 ES6 模块、CSS、图片、 JSON、Coffeescript、 LESS 等。 Webpack的目标 把依赖树拆成可按需加载的块 让初始化加载时间尽可能地少 每个静态资源都是一个模块 模块化集成第三方库 尽可能地自定义打包器的每一部分 尽可能地自定义打包器的每一部分 适合大型项目 webpack的特别之处代码拆分webpack 的依赖树中有同步和异步两种依赖方式。其中，异步模块将会被拆成一个新的块，并且在被优化后，生成一个对应的文件。 加载器webpack 本身只支持处理 JavaScript，但可以通过加载器来把别的资源转为 JavaScript。因此，每个资源都被当作一个模块。 智能解析webpack 有一个基本支持所有第三方库的智能解析器，甚至还支持带有表达式的依赖表述法，如 require(“./templates/“ + name + “.jade”)。支持最常用的 CommonJs 和 AMD 这两种模块风格。 插件系统webpack 有一个很出色的插件系统，甚至大部分内置功能都是基于这个插件系统而来的。这个插件系统允许你根据需要来自定义 webpack，以及通过开源的方式来分发通用插件。 创建Webpack的动机如今的网站正在朝着Web app演化，具体体现在： 在一个页面中包含越来越多的JavaScript代码 我们可以在现代的浏览器中做更多的事情 即使一个页面中有着越来越多的代码，但是几乎不会再进行整个页面的刷新 以上这几点会导致客户端（浏览器端）有着大量的代码。 如此多的代码需要被组织起来。模块系统给我们提供了把代码拆分成模块的可能。 现有的常用的模块系统风格 &lt;script&gt; 标签方式（无模块系统） CommonJs AMD 及其变种 ES6 模块 标签方式（无模块系统）这是在不使用模块系统的前提下来管理模块代码库的方式。 &lt;script src=&quot;libary1.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;libary2.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;plugin1.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;module1.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;module2.js&quot;&gt;&lt;/script&gt; 模块导出接口到全局对象中，如 window 对象，也通过全局对象来访问依赖模块的接口。 普遍的问题 全局变量冲突强依赖加载顺序开发者需要解决模块和库的依赖关系大项目中列表越来越长而难以维护 CommonJs：同步 require这是node.js使用的方式 这种方式使用同步的 require 来加载依赖并且通过给 exports 添加属性或给 module.exports 赋值来导出接口。 require(&quot;module&quot;); require(&quot;../file.js&quot;); exports.doStuff = function() {}; module.exports = someValue; 优点 重用服务端模块npm 上已经有很多这种模块简单且易于使用 缺点 网络请求不适用于同步请求，更适合异步请求不能并行请求多个模块 AMD：异步 require因为 CommonJs 的同步 require 方案不适合如浏览器等环境，所以有了异步的定义和导出模块方案。例如：require.js require([&quot;module&quot;, &quot;../file&quot;], function(module, file) { /* ... */ }); define(&quot;mymodule&quot;, [&quot;dep1&quot;, &quot;dep2&quot;], function(d1, d2) { return someExportedValue; }); 优点 适合异步网络请求方式并行加载多模块 缺点 更多的编码，更难阅读和编写有不同的方案 ES6 模块EcmaScript6 给 JavaScript 增加了模块系统。 import &quot;jquery&quot;; export function doStuff() {} module &quot;localModule&quot; {} 优点 易于静态分析（Typescript）未来的标准 缺点 浏览器原生支持需要时间（Babel）这种风格的模块还很少 模块的加载方式因为模块是在客户端执行的，所以首先需要把模块从服务端加载到浏览器。 关于模块加载，有两个极端的方案： 一个模块一个请求 所有模块一个请求 这两种方案都被广泛使用，但都不是最佳的。 一个模块一个请求优点： 按需加载 缺点： 过多请求导致负载过多，延迟过大，初始化慢 所有模块一个请求优点： 更少的负载，更少的延迟 缺点： 不需要或还不需要的模块也被加载了 分块加载在大多数情况下，各种极端方案的相互妥协会得到一个更好地方案。 编译模块时，把模块拆成更小的块（chunks） 这样，将得到多个更小的请求。模块的每个块（chunks）将是按需加载，初始请求中不包含完整的代码库，从而可以更小。 「拆分点」是可选的，并且可以由开发者自定义。 可以组成一个大的代码库 注：此思路来自GWT。 更多可参考代码拆分。 为何仅打包 JavaScript？为什么一个模块系统只能帮助开发者打包（模块化）JavaScript？实际上我们还有很多别的静态资源需要处理，如： 样式 图片 web 字体 html 模板 其他静态资源（.txt .pdf等） 另外还有一些预编译资源： typescript/coffeescript -&gt; javascript less/sass -&gt; css jade -&gt; 生成模板的 javascript i18n 文件 -&gt; 别的资源 其他 这些应该同样的使用才对，如： require(&quot;./style.css&quot;); require(&quot;./style.less&quot;); require(&quot;./template.jade&quot;); require(&quot;./image.png&quot;); 静态分析在编译模块时，会尝试用静态分析来获取依赖关系。 一般来说，这只能找到没有表达式的简单形式，但像 require(“./template/“ + templateName + “.jade”) 确实一种常见的用法。 不同的代码库往往使用不同的风格，其中不少的风格还是比较怪异的…… 解决问题的策略一个好的解析器应当支持绝大多数的现存代码。如果开发者用了一些不寻常的方法，那么解析器应该提供一个兼容性最好的解决方案。 Webpack安装node.js安装node.js node.js自带了一个叫做npm的包管理工具 Webpack我们使用npm安装Webpack $ npm install webpack -g 在项目中使用Webpack最好的方法是把 webpack 作为项目的依赖，这样，每个项目都可以使用自己所需要的版本而不必依赖于全局的 webpack。 通过 npm 来创建一个 package.json 文件： $ npm init 如果不把项目发布到 npm 上，在执行 npm init 命令中要求回答的问题的答案则不是很重要。 使用下面的命令来安装 webpack 并把其添加到 packeage.json 中： $ npm install webpack --save-dev 由于网络问题安装失败的朋友可以使用如下命令进行安装： npm install webpack --save-dev --registry=https://registry.npm.taobao.org Webpack版本选择webpack 有稳定版和 beta 版两个可用的版本，其中，beta 版本在版本号中添加了 -beta 的标识。beta 版本可能带有很多不稳定变更或实验性的功能，并且未完全测试。可查看变更记录来看各版本的差别。正式项目中应该使用稳定版本。 $ npm install webpack@1.2.x --save-dev Webpack开发者工具npm install webpack-dev-server --save-dev 复制如下代码到命令行执行，可快速安装npm install webpack webpack-dev-server --save-dev --registry=https://registry.npm.taobao.org 使用Webpack基本使用方式最基本的使用webpack的方式是在命令行中输入webpack相关的命令并执行，此时webpack 会分析入口文件（entry.js）来找寻依赖文件。这些依赖文件（又称之为模块）会包括到 bundle.js 中。webpack 会给每个模块一个唯一的 id，然后在 bundle.js 中通过该 id 来访问对应的模块。启动时，只会执行入口模块。一个短小的运行时提供了 require 函数，在引用模块时会执行依赖模块。 如果项目变得越来越大，编译耗时将会越来越长。所以，我们希望能够展示一些进度条，同时增加颜色 $ webpack --progress --colors 我们并不希望每一个变更都需要去手动编译，则可以通过以下命令来改善。 $ webpack --watch --progress --colors 这样，webpack 会缓存未变更的模块而输出变更的模块。 开启 webpack 监控模式后，webpack 会给所有文件添加用于编译的文件监控。如果有任何变更，将会触发编译。当缓存开启时，webpack 会在内存中保存所有模块内容并在没变更时直接重用。 但在实际项目中，一般不会这样使用。 通常会结合npm命令来在项目中使用Webpack。 npm 是一个非常好用的用来编译的指令，我们把webpack编译步骤放到 npm run build 中。通过 npm 我们可以不用去担心项目中使用了什么技术，你只要调用这个指令就可以了，只要你在 package.json 中设置 scripts 的值就可以了。 把下面的内容添加到 package.json中。 &quot;scripts&quot;: { &quot;build&quot;: &quot;webpack&quot; } 设置 webpack-dev-server如果需要一直输入 npm run build 确实是一件非常无聊的事情， 幸运的是，我们可以把让他安静的运行，让我们设置 webpack-dev-server。 安装webpack-dev-server npm i webpack-dev-server --save-dev 把下面的内容添加到 package.json中。 { &quot;scripts&quot;: { &quot;build&quot;: &quot;webpack&quot;, &quot;dev&quot;: &quot;webpack-dev-server --devtool eval --progress --colors --hot --content-base build&quot; } } webpack-dev-server - 在 localhost:8080 建立一个 Web 服务器–devtool eval - 为你的代码创建源地址。当有任何报错的时候可以让你更加精确地定位到文件和行号–progress - 显示合并代码进度–colors - 命令行中显示颜色–content-base build - 指向设置的输出目录 访问 http://localhost:8080 会看到效果 webpack.config.js在项目根目录手动创建名为webpack.config.js的配置文件, Webpack 在执行的时候，除了在命令行传入参数，还可以通过指定的配置文件来执行。默认情况下，会搜索当前目录的 webpack.config.js 文件。 浏览器自动刷新webpack-dev-server阻止了 webpack 生成结果文件到硬盘，而是直接通过内存来提供服务 当运行 webpack-dev-server 的时候，它会监听你的文件修改。当项目重新合并之后，会通知浏览器刷新。 为了能够触发这样的行为，你需要把你的 index.html 放到 build/ 文件夹下， 然后，需要在index.html中增加一个脚本当发生改动的时候去自动刷新应用： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;/&gt; &lt;/head&gt; &lt;body&gt; &lt;script src=&quot;http://localhost:8080/webpack-dev-server.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;bundle.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 在webpack.config.js配置中增加一个入口点 var path = require(&apos;path&apos;); module.exports = { entry: [&apos;webpack/hot/dev-server&apos;, path.resolve(__dirname, &apos;app/main.js&apos;)], output: { path: path.resolve(__dirname, &apos;build&apos;), filename: &apos;bundle.js&apos;, }, }; 现在应用就可以在文件修改之后自动刷新了 默认自动刷新方式在上面我们创建了 index.html 文件来获取更多的自由和控制，这样在http://localhost:8080/就可以自动刷新。 另一种方式是不需要创建index.html, 直接访问http://localhost:8080/webpack-dev-server/bundle 运行应用。 这会触发一个默认的我们不能控制的 index.html ，它同样会触发一个允许iFrame中显示重合并的过程。webpack 命令会尝试加载当前目录下的 webpack.config.js 文件。 加载器加载器是把一个资源文件作为入参转换为另一个资源文件的 node.js 函数。 安装加载器如果加载器发布在 npm 上，那么可以通过下面的两个命令来安装 $ npm install xxx-loader --save $ npm install xxx-loader --save-dev 加载器用法请参见在项目中使用webpack+react+es6 参考Webpack Document Webpack 中文指南 webpack-doc Webpack傻瓜式指南（一） Webpack傻瓜指南（二）开发和部署技巧 Webpack傻瓜指南（三）和React配合开发]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rem]]></title>
    <url>%2F2016%2F03%2F21%2Frem%2F</url>
    <content type="text"><![CDATA[rem之前常用的两种计量单位px：优点是方便、稳定、精确、一致；缺点是改变了浏览器的字体大小，页面布局会被打破 em：可以解决在浏览器中放大或缩放浏览页面时，布局被打破的问题。但是由于em是一个相对于父元素的相对值，下面代码li标签的font-size是不确定的。 （ 1 ÷ 父元素的font-size × 需要转换的像素值 = em值 ——&gt; 需要转换的像素值 ÷ 父元素的font-size = em值 ） body { font-size: 62.5%; /*10 ÷ 16 × 100% = 62.5%*/ } h1 { font-size: 2.4em; /*2.4em × 10 = 24px */ } p { font-size: 1.4em; /*1.4em × 10 = 14px */ } li { font-size: 1.4em; /*1.4 × ? = 14px ? */ } rem在W3C官网上是这样描述rem的：font size of the root element。 也就是说，rem是指根元素（root element，html）的字体大小。 令人高兴的是：从遥远的 IE6 到版本帝 Chrome 他们都约好了，根元素默认的 font-size 都是 16px 如何使用rem先来看一下这张表： 示例代码： html{ font-size:62.5%; /* 10÷16=62.5% */ } body{ font-size:12px; font-size:1.2rem ; /* 12÷10=1.2 */ } p{ font-size:14px; font-size:1.4rem; } rem浏览器兼容性IE9+，Firefox、Chrome、Safari、Opera 的主流版本都支持 参考CSS3的REM设置字体大小 响应式十日谈第一日：使用 rem 设置文字大小]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[innerHTML和innerText区别]]></title>
    <url>%2F2016%2F03%2F21%2FinnerHTML-and-innerText%2F</url>
    <content type="text"><![CDATA[innerHTML指的是从对象的起始位置到终止位置的全部内容,包括Html标签。 innerText指的是从起始位置到终止位置的内容,但它去除Html标签。 outerHTML指的是除了包含innerHTML的全部内容外, 还包含对象标签本身。 innerHTML是符合W3C标准的属性，而innerText只适用于IE浏览器（现在也适应chrome浏览器），因此，尽可能地去使用 innerHTML，而少用innerText，如果要输出不含HTML标签的内容，可以使用innerHTML取得包含HTML标签的内容后，再用正则表达式去除HTML标签。 下面是一个简单的符合W3C标准的示例： &lt;script&gt; var content = document.getElementById(“p1″); alert(content.innerHTML.replace(/&amp; lt;.+?&gt;/gim,”)); &lt;/script&gt;]]></content>
      <tags>
        <tag>查缺补漏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[别问白痴问题]]></title>
    <url>%2F2016%2F03%2F21%2F%E5%88%AB%E9%97%AE%E7%99%BD%E7%97%B4%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[加入丁香园第三天。第一天主要是报道，完善个人信息，配置开发环境，申请相关账号，熟悉团队同事和环境。第二天，主要是熟悉团队目前所使用技术，下午leader给了一个Ueditor的小活儿，下班前找到了解决方案并亲测可用。第三天，上午把解决方案与同事配合，把code更新到产品线。下午参加了技术产品部的年会，晚上公司请大家去吃海底捞。。。 以上都不是重点。重点想记下的是，上午导师跟我说，大多数产品的静态资源都是单独放在一个服务器上的。在本地前端开发需要用Apache弄一个虚拟主机。由于之前的两个较为完整的网站开发维护经历，都没有这么做过。自己便随口说了一句：这么做有什么好处呢？ 导师听了这话，顿了一下说：你先自己想想，然后再问我。当时突然有种被人用拳头朝着太阳穴狠狠打了一下的感觉。是啊！自己是应该先自己仔细思考后，再问别人的。之前就有过这样的教训的，可是这次又一次说话不经脑子。 其实，就技术而言，“外事不决问Google”已经可以解决掉一大半问题了。遇到了问题，如果Google并没有找到解决办法，通常需要做的事情是：调整一下自己面对问题的心态，仔细想想遇到的到底是什么问题，什么情况下发生的，多问自己几个为什么，耐心的再去读几遍bug信息，长呼一口气，然后更加耐心仔细的去Google解决方案。等到狠狠的逼自己解决几次，还是搞不定，则可以考虑问身边的伙伴寻找解决办法了。 今天最想记下来的写完了。希望自己不要再犯这种白痴的毛病。 还想写下的是，年会上Fenng和robbin都提到了拥抱变化，这一点上他们说的确实是有道理的。自己也进一步理解了阿里当时说的“拥抱变化”。总之，平台是好的，团队是好的，发展前景是好的，如果未来有一天，自己觉得受委屈了或是怎样，那么99%是自己出了问题，自己的level不够高。如果有人跟我说，这个团队的种种问题，或许我也会承认它确实有，不过，自己已经经历了两个创业团队了，哪一个团队没有自身的问题呢。吐槽埋怨的时间还是用来解决问题，push团队变得更好吧。 最后，近两百人的团队一起去吃海底捞的感觉挺爽的。]]></content>
      <tags>
        <tag>自省</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识backbone]]></title>
    <url>%2F2016%2F03%2F21%2Ffirst-meet-backbone%2F</url>
    <content type="text"><![CDATA[Backbone的MVC结构 数据模型（Model）：负责数据原型的创建和各类事件的自定义，并通过key/value形式绑定原型数据。 数据模型集合（Collection）：所提供的API向原型中添加各类数据。 视图控制器（View）：绑定页面中元素的内容并处理相应的事件，并通过RESTful JSON接口方式与原有应用程序中的数据进行动态交互。 特点 MVC结构化：开发人员可以很方便的组织和开发自己的代码，真正做到数据交互、逻辑处理、页面展示的分离；并可以组织分工开发，减少重复开发，提高代码的开发效率和可维护性。 继承特性：能以面向对象的方式编写自己的数据、集合、视图模型，而且这些模型都具有可继承性。这使得开发人员可以很方便地重载这些模型和扩展一些自定义的属性和方法。 事件统一管理 绑定页面模板：可以直接调用页面中的HTML模板。好处：一是可以在HTML模板中嵌入JS代码，无须动态生成HTML元素时拼接字符串，减少页面执行时的出错率；二是可以在视图中管理页面中的模板，即定义多套HTML页面模板，再根据实际需要选择加载和页面的渲染，极大提升了前段开发人员的工作效率。 服务端无缝交互：在Backbone内部中，有一整套与服务器数据自动同步的机制，用户只需要关注客户端的操作，执行完这些操作后的数据将会在模型中自动同步到服务器中。 学习过程中的代码code]]></content>
      <tags>
        <tag>Backbone</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo Error spawn git ENOENT]]></title>
    <url>%2F2016%2F01%2F28%2Fhexo-deployed-error-spawn-git-ENOENT%2F</url>
    <content type="text"><![CDATA[错误hexo部署博客到GitHub上，执行hexo -d时，报如下错误 Error: spawn git ENOENT at exports._errnoException (util.js:746:11) at Process.ChildProcess._handle.onexit (child_process.js:1053:32) at child_process.js:1144:20 at process._tickCallback (node.js:355:11) 原因未添加Git环境变量/之前添加成功了但是由于某种原因，环境变量现在失效了 解决重新添加Git到环境变量即可 Win10添加环境变量后截图：]]></content>
      <tags>
        <tag>Bugs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cmder使用小记]]></title>
    <url>%2F2016%2F01%2F21%2Fcmder%2F</url>
    <content type="text"><![CDATA[将cmder加入环境变量 添加成功： 添加 cmder 到右键菜单以管理员权限打开终端，并输入如下命令： Cmder.exe /REGISTER ALL 中文乱码、错位乱码将下面的4行命令添加到cmder/config/aliases文件末尾 l=ls --show-control-chars la=ls -aF --show-control-chars ll=ls -alF --show-control-chars ls=ls --show-control-chars -F 重叠通过快捷键win+alt+p:打开设置面板，去掉Monospace前面的勾选]]></content>
      <tags>
        <tag>编程工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分享网页到朋友圈带缩略图]]></title>
    <url>%2F2016%2F01%2F21%2F%E5%88%86%E4%BA%AB%E7%BD%91%E9%A1%B5%E5%88%B0%E6%9C%8B%E5%8F%8B%E5%9C%88%E5%B8%A6%E7%BC%A9%E7%95%A5%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[这是一个不使用微信的JS-SDK实现分享网页到朋友圈带缩略图的方法。 具体步骤：1.紧接着&lt;body&gt;标签添加如下代码： &lt;div class=&quot;wechat-share-picture&quot;&gt; &lt;img src=&quot;share-picture.png&quot;&gt; &lt;/div&gt; 2.图片尺寸大小要大于等于300px*300px 3.添加css代码 .wechat-share-picture { display: none; }]]></content>
  </entry>
  <entry>
    <title><![CDATA[进程vs线程vs协程]]></title>
    <url>%2F2016%2F01%2F21%2F%E8%BF%9B%E7%A8%8Bvs%E7%BA%BF%E7%A8%8Bvs%E5%8D%8F%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[背景1.CPU执行代码都是顺序执行的2.真正的并行执行多任务只能在多核CPU上实现3.单核CPU执行多任务：操作系统轮流让各个任务交替执行4.多进程、多线程以及异步IO要解决的问题：CPU高速执行能力和IO设备的龟速严重不匹配 进程对于操作系统来说，一个任务就是一个进程（Process），比如打开一个浏览器就是启动一个浏览器进程，打开一个记事本就启动了一个记事本进程 线程有些进程还不止同时干一件事，比如Word，它可以同时进行打字、拼写检查、打印等事情。在一个进程内部，要同时干多件事，就需要同时运行多个“子任务”，我们把进程内的这些“子任务”称为线程（Thread）由于每个进程至少要干一件事，所以，一个进程至少有一个线程。当然，像Word这种复杂的进程可以有多个线程，多个线程可以同时执行，多线程的执行方式和多进程是一样的，也是由操作系统在多个线程之间快速切换，让每个线程都短暂地交替运行，看起来就像同时执行一样。当然，真正地同时执行多线程需要多核CPU才可能实现。 线程是最小的执行单元，而进程由至少一个线程组成。如何调度进程和线程，完全由操作系统决定，程序自己不能决定什么时候执行，执行多长时间。 多任务的实现有3种方式：多进程模式；多线程模式；多进程+多线程模式（实际采用较少）。 多进程和多线程的优缺点首先，要实现多任务，通常我们会设计Master-Worker模式，Master负责分配任务，Worker负责执行任务，因此，多任务环境下，通常是一个Master，多个Worker。 如果用多进程实现Master-Worker，主进程就是Master，其他进程就是Worker。如果用多线程实现Master-Worker，主线程就是Master，其他线程就是Worker。 多进程模式最大的优点就是稳定性高，因为一个子进程崩溃了，不会影响主进程和其他子进程。（当然主进程挂了所有进程就全挂了，但是Master进程只负责分配任务，挂掉的概率低）著名的Apache最早就是采用多进程模式。 多进程模式的缺点是创建进程的代价大，在Unix/Linux 系统下，用fork调用还行，在Windows下创建进程开销巨大。另外，操作系统能同时运行的进程数也是有限的，在内存和CPU的限制下，如果有几千个进程同时运行，操作系统连调度都会成问题。 多线程模式通常比多进程快一点，但是也快不到哪去，而且，多线程模式致命的缺点就是任何一个线程挂掉都可能直接造成整个进程崩溃，因为所有线程共享进程的内存。在Windows上，如果一个线程执行的代码出了问题，你经常可以看到这样的提示：“该程序执行了非法操作，即将关闭”，其实往往是某个线程出了问题，但是操作系统会强制结束整个进程。 在Windows下，多线程的效率比多进程要高，所以微软的IIS服务器默认采用多线程模式。由于多线程存在稳定性的问题，IIS的稳定性就不如Apache。为了缓解这个问题，IIS和Apache现在又有多进程+多线程的混合模式。 如果有几千个任务同时进行，操作系统可能就主要忙着切换任务，根本没有多少时间去执行任务了，这种情况最常见的就是硬盘狂响，点窗口无反应，系统处于假死状态。多任务一旦多到一个限度，就会消耗掉系统所有的资源，结果效率急剧下降，所有任务都做不好。无论是多进程还是多线程，只要数量一多，效率肯定上不去。 计算密集型 vs IO密集型我们可以把任务分为计算密集型和IO密集型。 计算密集型任务的特点是要进行大量的计算，消耗CPU资源，比如计算圆周率、对视频进行高清解码等等，全靠CPU的运算能力。这种计算密集型任务虽然也可以用多任务完成，但是任务越多，花在任务切换的时间就越多，CPU执行任务的效率就越低，所以，要最高效地利用CPU，计算密集型任务同时进行的数量应当等于CPU的核心数。 计算密集型任务由于主要消耗CPU资源，因此，代码运行效率至关重要。Python这样的脚本语言运行效率很低，完全不适合计算密集型任务。对于计算密集型任务，最好用C语言编写。 第二种任务的类型是IO密集型，涉及到网络、磁盘IO的任务都是IO密集型任务，这类任务的特点是CPU消耗很少，任务的大部分时间都在等待IO操作完成（因为IO的速度远远低于CPU和内存的速度）。对于IO密集型任务，任务越多，CPU效率越高，但也有一个限度。常见的大部分任务都是IO密集型任务，比如Web应用。 IO密集型任务执行期间，99%的时间都花在IO上，花在CPU上的时间很少，因此，用运行速度极快的C语言替换用Python这样运行速度极低的脚本语言，完全无法提升运行效率。对于IO密集型任务，最合适的语言就是开发效率最高（代码量最少）的语言，脚本语言是首选，C语言最差。 异步IO考虑到CPU和IO之间巨大的速度差异，一个任务在执行的过程中大部分时间都在等待IO操作，单进程单线程模型会导致别的任务无法并行执行，因此，我们才需要多进程模型或者多线程模型来支持多任务并发执行。 另一个办法是：当代码需要执行一个耗时的IO操作时，它只发出IO指令，并不等待IO结果，然后就去执行其他代码了。一段时间后，当IO返回结果时，再通知CPU进行处理。 现代操作系统对IO操作已经做了巨大的改进，最大的特点就是支持异步IO。如果充分利用操作系统提供的异步IO支持，就可以用单进程单线程模型来执行多任务，这种全新的模型称为事件驱动模型，Nginx就是支持异步IO的Web服务器，它在单核CPU上采用单进程模型就可以高效地支持多任务。在多核CPU上，可以运行多个进程（数量与CPU核心数相同），充分利用多核CPU。由于系统总的进程数量十分有限，因此操作系统调度非常高效。用异步IO编程模型来实现多任务是一个主要的趋势。 异步IO模型需要一个消息循环，在消息循环中，主线程不断地重复“读取消息-处理消息”这一过程 对应到Python语言，单进程的异步编程模型称为协程，有了协程的支持，就可以基于事件驱动编写高效的多任务程序。 协程协程，又称微线程，纤程。英文名Coroutine。 子程序，或者称为函数，在所有语言中都是层级调用，比如A调用B，B在执行过程中又调用了C，C执行完毕返回，B执行完毕返回，最后是A执行完毕。 所以子程序调用是通过栈实现的，一个线程就是执行一个子程序。 子程序调用总是一个入口，一次返回，调用顺序是明确的。而协程的调用和子程序不同。 协程看上去也是子程序，但执行过程中，在子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行。 注意，在一个子程序中中断，去执行其他子程序，不是函数调用，有点类似CPU的中断。 协程的特点在于是一个线程执行 协程优势最大的优势就是协程极高的执行效率。因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显。 第二大优势就是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。 协程如何利用多CPU最简单的方法是多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能 Donald Knuth的一句话总结协程的特点：“子程序就是协程的一种特例。”]]></content>
      <tags>
        <tag>查缺补漏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django 初级]]></title>
    <url>%2F2015%2F12%2F27%2Ffirst-meet-django%2F</url>
    <content type="text"><![CDATA[Django 环境搭建 及 第一个项目安装python安装python 安装pip用get-pip.py来安装pip：https://pip.pypa.io/en/latest/installing.html Linux, Mac OSX, Windows下均可以使用该方法 升级pip pip install --upgrade pip 安装Djangopip install Django 检查Django是否安装成功如果成功，会输出Django版本号 python -c &quot;import django; print(django.get_version())&quot; 创建项目在命令行cd到一个想在该位置创建项目的位置，执行如下代码(mysite为项目名称) django-admin startproject mysite 需要注意两点： You’ll need to avoid naming projects after built-in Python or Django components. In particular,this means you should avoid using names like django (which will conflict with Django itself) ortest (which conflicts with a built-in Python package). Where should this code live?If your background is in plain old PHP (with no use of modern frameworks),you’re probably used to putting code under the Web server’s document root (in a place such as /var/www).With Django, you don’t do that.It’s not a good idea to put any of this Python code within your Web server’s document root,because it risks the possibility that people may be able to view your code over the Web.That’s not good for security.Put your code in some directory outside of the document root, such as /home/mycode. 运行项目（该内置服务器仅限于开发时使用）python manage.py runserver or python manage.py runserver 8080 or python manage.py runserver 0.0.0.0:8000 在mysite项目下创建一个名字为polls的应用python manage.py startapp polls 分别编辑如下文件： polls/views.py from django.http import HttpResponse def index(request): return HttpResponse(&quot;Hello, world. You&apos;re at the polls index.&quot;) 创建polls/urls.py，并添加如下代码 from django.conf.urls import url from . import views urlpatterns = [ url(r&apos;^$&apos;, views.index, name=&apos;index&apos;), ] mysite/urls.py from django.conf.urls import include, url from django.contrib import admin urlpatterns = [ url(r&apos;^admin/&apos;, admin.site.urls), url(r&apos;^polls/&apos;, include(&apos;polls.urls&apos;)), ] 创建项目、应用以及其他详细说明 参见Django官方新手文档]]></content>
      <tags>
        <tag>Django初级</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个成功的Git分支模型]]></title>
    <url>%2F2015%2F12%2F12%2Fuse-git%2F</url>
    <content type="text"><![CDATA[自从博客搭起来，迟迟没有写东西。 通过一直关注的锤子科技，了解到国内软件开发这个江湖，有池建强这样一号人，随之了解到MacTalk，竟发现自己会欣赏加佩服池老师这种人。 前日深夜，泊洲兄发了一份深夜福利，并说：我们把他翻译过来吧。我想，是时候动起来了。 万一自己真的像初中语文老师说的那样，将来我可以成为一个文豪呢~ 福利是一篇外国人写的关于Git分支管理的文章，原名为A successful Git branching model，推荐做开发的伙伴阅读一下。 以下内容是基于版本控制工具Git展开的，最开始接触版本控制工具，用的是TortoiseHg,用了一段时间Git后，赶脚还是Git好一些。 推荐一份Git教程 以下是我对原文的翻译，不足之处欢迎指出： 分布而集中该分支模型有一个真正意义上的中央仓库，并且这个中央仓库是唯一的。 （Git本身是分布式版本控制系统，在技术层面上，是没有中央仓库这个说法的。） 我们称这样的一个中央仓库为origin。所有的Git用户对origin这个名字都应该比较熟悉的。 在一个项目的开发team中，每个开发者，都可以从origin获得（pull）资源，同时也能推送（push）到origin。 此外，每个开发者可以从其他开发者那里获得资源，以此组建一个开发小组。 例如，当我们和其他人一起协作开发一个大的新功能时，在提交自己的改动到中央仓库origin之前， 我们需要自己所在小组内部能够互相协作，这将是十分有用的。 上图中，Alice和Bob是一个小组，同时Alice和David是一个小组，Clair和David又是一个小组。 从技术实现上讲，这无非是在Alice的项目里，定义了一个指向Bot的远程链接而已 （git remote add bob git@bobserver bob.git)，反之亦然。 主分支中央仓库有2个主要的分支，这些分支将一直存在： master develop 所有Git用户都会知道中央仓库的master分支，与master分支并行的另外一个分支，我们称之为develop。 我们称origin/master为主要分支，因为分支的HEAD指向的源码总是反映了一个可以发布的产品状态（production-ready）。 我们称origin/develop为主要分支，因为分支的HEAD指向的源码，总是反映了下次发布前最新提交的开发代码。 有些人称之为“集成分支”（integration branch），因为我们的每晚自动构建都是基于此分支进行的。 （例如hudson，可以做自动构建工作）。 当develop分支的源码稳定并且准备发布，所有的改变应该合并（merge）到master分支，同时做一个发布版本的标签（tag）。 当每一次将develop所有更改合并回master时，将会产生一个新的可以发布的产品状态。 如果使用Git的hook来自动构建和转出最新代码到产品服务器上，那么develop合并到master上的操作一定要多加小心。 辅助分支除了两个主分支之外，分支模型使用多种辅助分支来支持团队成员之间的并行开发、新功能的持续开发、 为产品发布做准备、快速修复产品线上的bug等。 与主要分支不同的是，辅助分支都有一个有限的生命周期，因为他们最终会被删除。 我们可能会用到的分支有： 功能分支 发布分支 修补程序分支 每创建一个辅助分支都是有一个明确的目的。并且会严格规定该辅助分支是从哪个主分支fork过来的， 最终要merge到哪个分支上。 从技术角度来看，这些分支并没有特别之处。不过我们是从用途的角度来划分这些辅助分支的。 当然，这些分支都是从主分支fork过来的。 功能分支可从哪个分支fork： develop 必须合并回哪个分支： develop 分支的命名规则： 除了master ， develop ， release-或hotfix-之外的任意名字 功能分支（主题分支）被用于开发即将到来的或遥远的未来版本的新功能。 在创建一个功能分支进行开发时，该分支合并到develop分支的时间节点可能是不确定的， 但是最终会被合并到develop分支或者丢弃。 功能分支通常只存在于开发者本地的仓库，并不会被推送到远程（origin）。 当开发一个新功能时，从develop创建分支： $ git checkout -b myfeature develop Switched to a new branch &quot;myfeature&quot; 新功能开发完成后，将功能分支合并到develop分支，并将develop分支推送到远程。 $ git checkout develop Switched to branch &apos;develop&apos; $ git merge --no-ff myfeature Updating ea1b82a..05e9557 (Summary of changes) $ git branch -d myfeature Deleted branch myfeature (was 05e9557). $ git push origin develop 发布分支可从哪个分支fork： develop 必须合并回哪个分支： develop和master 分支的命名规则： release-* 发布分支用来支持产品的更新。它允许最后一分钟的点缀我的和交叉T的。 此外，它允许修正一些小错误和准备即将发布版本的元数据（例如：版本号，构建日期等）。 在发布分支上做完以上工作，并将该分支合并到develop和master后， develop分支就可以“干净的”等待新功能分支的到来了。 从develop分支创建一个发布分支的时间点为：在新的release版本即将发布之前， develop分支达到了最理想的状态（所有本次更新要更新出去的新功能已经被合并到develop分支， 下一次发布的新功能还没有从release分支fork）。 在创建一个发布分支的刚开始，即将发布的分支才会被分配一个版本号。 在这个时刻之前，develop分支虽然已经反映了“下一个版本”的变化，但是自己并不知道 “下一个版本”最终会变为0.4还是1.0。 创建一个发布分支 发布分支从develop分支创建。例如，当前已经发布产品的版本号为1.1.5，该产品即将有一个大的更新。 develop分支已经准备好被更新出去并且我们决定新版本号为1.2。 $ git checkout -b release-1.2 develop Switched to a new branch &quot;release-1.2&quot; 发布版本会存在一段时间，直至新版本更新到外网。在这段时间，fix bugs的工作在该分支上进行。 严禁在该分支上增加大的功能点。这种功能上的改动必须被merge到develop分支，等待下一次更新。 完成一个发布分支 当发布分支真正的可以发布时，还需要做两件事情。 第一，将该发布分支合并到master分支，并且要为这个merge做一个方便以后查看历史版本的tag。 $ git checkout master Switched to branch &apos;master&apos; $ git merge --no-ff release-1.2 Merge made by recursive. (Summary of changes) $ git tag -a 1.2 第二，将该发布分支合并到develop分支。 $ git checkout develop Switched to branch &apos;develop&apos; $ git merge --no-ff release-1.2 Merge made by recursive. (Summary of changes) 当产品发布完成之后，删除发布分支： $ git branch -d release-1.2 Deleted branch release-1.2 (was ff452fe). 修补程序分支可从哪个分支fork： master 必须合并回哪个分支： develop和master 分支的命名规则： hotfix-* 修补程序分支和发布分支非常相似，因为他们都是为一个新产品的发布做准备。 当线上产品出现严重bug，而此时develop分支尚不稳定时，我们就需要创建一个修补程序分支。 这样做的一个好处就是，当一个人准备修复线上产品的bug时，其他团队成员（在develop分支）可以继续工作。 创建修补程序分支 $ git checkout -b hotfix-1.2.1 master Switched to a new branch &quot;hotfix-1.2.1&quot; 接下来开始fix bug，并进行一次或多次的commit $ git commit -m &quot;Fixed severe production problem&quot; [hotfix-1.2.1 abbe5d6] Fixed severe production problem 5 files changed, 32 insertions(+), 17 deletions(-) fix bugs完成 $ git checkout master Switched to branch &apos;master&apos; $ git merge --no-ff hotfix-1.2.1 Merge made by recursive. (Summary of changes) $ git tag -a 1.2.1 $ git checkout develop Switched to branch &apos;develop&apos; $ git merge --no-ff hotfix-1.2.1 Merge made by recursive. (Summary of changes) 唯一的例外是，当发布分支存在并且线上bugs可以等到发布分支的最终发布时再fix， 我们可以把修补程序分支合并到发布分支，不必再合并到develop分支。 $ git branch -d hotfix-1.2.1 Deleted branch hotfix-1.2.1 (was abbe5d6).]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hello, world]]></title>
    <url>%2F2015%2F10%2F07%2Fhello%20world%2F</url>
    <content type="text"><![CDATA[是时候重新审视自己和这个世界了。]]></content>
  </entry>
</search>
